<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    </head>
    <body>
        <h2 id="-">자바 중고급프로그래밍</h2>
<table>
<thead>
<tr>
<th>일차</th>
<th>주제</th>
<th>시간</th>
<th>학습 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>자바의 개요 클래스와 객체 상속과 다형성 예외처리 내부 클래스</td>
<td>8H</td>
<td>자바의 소개 <br/>지역과 전역변수, 메모리관리 <br/>객체생성과 메모리<br/>Extends / implements<br/>다형성, 상속의 활용<br/>사용자정의 exception<br/>내부클래스</td>
</tr>
<tr>
<td>2</td>
<td>컬렉션 제네릭 IO 람다식 Stream<br> API</td>
<td>8H</td>
<td>제네릭 <br/>컬렉션 API <br/>Iterating<br/>ByteStream,FilterStream <br/>Character Stream, conversion <br/>Lambda Expression,<br> Functional Interface  <br/>Stream</td>
</tr>
<tr>
<td>3</td>
<td>병렬처리 통신</td>
<td>8H</td>
<td>쓰레드 동작방식과 메모리<br/>라이프사이클<br/>쓰레드풀,Callable,Future<br/>웹스크래핑,멀티통신<br/>프로토콜의 의의<br/>웹서버 구현<br/>사후테스트(실기평가/ 2H)</td>
</tr>
</tbody>
</table>
<p>❊ 본 문서는 Copilot GPT을 활용하여 AI와 함께 작성되었습니다.</p>
<p>❊❊ 이 문서의 코드는 각 쳅터를 대표하고 간략한 최소한의 코드만을 첨부하였기에 강의 전체의 코드는 아래의 git레포지토리 사이트를 통해 git clone 또는 zip 압축 download를 통해 확인하시길 바랍니다.</p>
<p><a href="https://github.com/daegu010/java2024.git">https://github.com/daegu010/java2024.git</a></p>
<p>## </p>
<h3 id="1-">1일차</h3>
<h3 id="-">자바란</h3>
<p><strong>자바 (Java)</strong>는 1995년 미국의 썬마이크로시스템즈라는 회사에서 개발한 객체지향 언어입니다. 현재는 오라클에 인수되어 배포되고 있으며, 다양한 플랫폼과 운영체제에서 사용됩니다. 자바는 안정성, 이식성, 확장성 등 다양한 장점을 가지고 있습니다. 이 언어는 다음과 같은 몇 가지 주요 용도로 활용됩니다</p>
<ul>
<li><p>웹애플리케이션 개발: 자바는 웹 애플리케이션을 개발하는 데 널리 사용됩니다.</p>
</li>
<li><p>스마트폰어플 개발: 안드로이드 애플리케이션을 만들기 위해 자바를 활용할 수 있습니다.</p>
</li>
<li><p>웹서버 개발: 자바는 서버 측 기술에 사용되어 동적이고 상호작용적인 웹 어플리케이션을 만들 수 있게 합니다.</p>
</li>
<li><p>빅데이터 처리: 복잡한 데이터 집합과 방대한 양의 실시간 데이터를 처리하는 데 사용됩니다.</p>
</li>
<li><p>인공 지능 및 머신러닝: 기계 학습 라이브러리의 발전소 역할을 합니다.</p>
</li>
</ul>
<p>자바는 다양한 기능과 라이브러리로 구성된 풍부한 에코시스템을 제공하며, 고품질 학습 리소스와 적극적인 커뮤니티 지원도 가지고 있습니다. 또한 플랫폼 독립적이어서 여러 디바이스에서 실행할 수 있습니다. 이러한 이유로 자바는 여전히 프로그래머들 사이에서 많은 인기를 끌고 있습니다.</p>
<h3 id="-">역사</h3>
<p><img src="https://www.lgcns.com/wp-content/uploads/2021/12/231C003B55C0260028.png" alt=""></p>
<p>자바 언어 : 미국
선(Sun)마이크로시스템사의 컴퓨터 과학자인 제임스 고슬링(James Gosling)에 의해 개발된 언어</p>
<p>– 가전제품의 기능을 프로그램으로 제공하기 위해 개발</p>
<p>– 제임스 고슬링은 앞으로 많은 가전제품(전화, TV, 비디오, 컴퓨터 등)들이 하나의 거대한 네트워크에 연동될 것으로 예측하였고, 또한 제품들의 기능을 제공하는 내장된 프로그램(embeddedprogram)들이 부품(component)처럼 사용될 것이라고 예측</p>
<p>– 오크 언어의 많은 개념들을 그대로 이어받았음</p>
<p>– C/C++에서 어렵게 사용되는 포인터나 메모리 조작 등의 개념을 과감하게 제거하거나 개선</p>
<p>– 신뢰성을 증대시키기 위해 예외 처리(exception-handling)기능을 효율적으로 제공하여 예상치 못한 오류 등을 처리하는 방법을 제공</p>
<p>– 많은 가전사들의 무관심과 현실성에 대한 문제 때문에 별로관심을 끌지 못함</p>
<p>– 1995년 JAVA베타 2버전이 탄생</p>
<p>– 1996년 JAVA 1.0이 공식 발표</p>
<p>– 이후 웹 생태계와 만나 대 성공을 이룸</p>
<h3 id="-">장점</h3>
<p>고품질 학습 리소스</p>
<p>Java는 오랫동안 사용되어 왔기 때문에 새로운 프로그래머가 사용할 수 있는 학습 리소스가 많이 있습니다. 개발자를 학습 과정 내내 활용할 수 있는 자세한 설명서, 포괄적인 책, 과정이 마련되어 있습니다. 또한 초보자는 Advanced Java로 넘어 가기 전에 Core Java에서 코드 작성을 시작할 수 있습니다.</p>
<p>기본 제공 함수 및 라이브러리</p>
<p>Java를 사용하면 개발자가 처음부터 모든 새로운 기능을 작성할 필요가 없습니다. 대신 Java는 다양한 애플리케이션을 개발하기 위해 기본 제공 기능과 라이브러리로 구성된 풍부한 에코시스템을 제공합니다.</p>
<p>적극적인 커뮤니티 지원</p>
<p>Java에는 코딩 문제 발생 시 개발자를 지원할 수 있는 많은 활성 사용자와 커뮤니티가 있습니다. Java 플랫폼 소프트웨어도 정기적으로 유지 관리되고 업데이트됩니다.</p>
<p>고품질 개발 도구</p>
<p>Java는 자동화 편집, 디버깅, 테스트, 배포 및 변경 관리를 지원하는 다양한 도구를 제공합니다. 이러한 도구는 Java 프로그래밍을 시간과 비용 효율적으로 만듭니다.</p>
<p>플랫폼 독립적</p>
<p>Java 코드는 다시 작성하지 않고도 Windows, Linux, iOS 또는 Android와 같은 기본 플랫폼에서 실행할 수 있습니다. 따라서 여러 디바이스에서 애플리케이션을 실행하려는 오늘날의 환경에서 특히 유용합니다.</p>
<p>보안</p>
<p>사용자는 네트워크를 통해 신뢰할 수 없는 Java 코드를 다운로드하고 해당 Java 코드가 해를 끼칠 수 없는 안전한 환경에서 이를 실행할 수 있습니다. 신뢰할 수 없는 코드가 호스트 시스템을 바이러스에 감염시킬 수 없으며 하드 드라이브에서 파일을 읽거나 쓸 수 없습니다. Java의 보안 수준 및 제한 사항도 고도로 구성 가능합니다.</p>
<h3 id="-">자바의 특징</h3>
<p>자바(Java)는 다음과 같은 주요 특징을 가진 프로그래밍 언어입니다</p>
<ul>
<li><p>간단함: 자바는 배우기 쉽고, 구문이 간단하며 이해하기 쉽습니다.</p>
</li>
<li><p>객체 지향적: 자바는 완벽한 객체 지향 언어로, 애플리케이션의 기능을 오브젝트의 조합으로 구현합니다.</p>
</li>
<li><p>플랫폼 독립성: 자바 프로그램은 Java 가상 머신(JVM)에서 실행되므로, 어떤 하드웨어나 운영체제에서도 실행할 수 있습니다.</p>
</li>
<li><p>강력함: 자바는 분산형, 다중 스레드, 고성능 등의 특징을 가지며, 보안과 견고함에 중점을 둡니다.</p>
</li>
</ul>
<p>이 외에도 자바는 인터프리터 언어이며, 아키텍처 중립적이고, 동적인 언어입니다</p>
<p><strong>인터프리터 언어이다 (Interpreted)</strong></p>
<p>자바는 정확하게 말하면 컴파일 언어인 동시에 인터프리터 언어이다. 자바는 먼저 텍스트 소스를 컴파일하여 이진 파일(클래스 파일)로 만든 다음, 자바 런타임이 이 클래스 파일을 인터프리트 interpret 하면서 실행한다. 자바는 먼저 시스템과 무관한 이진파일을 만듦으로써 컴파일 언어에 가까운 속도와 함께 시스템의 독립성을 얻을 수 있었다.</p>
<p>인터프리터 언어는 코드를 한 줄씩 작성하고 실행하여 결과를 바로 확인할 수 있다.</p>
<p>자바의 메모리 사용방식</p>
<p>java프로그램은 JVM(Java Virtual Machine : 자바가상머신)이라는 프로그램만 있으면 실행이 가능한데, JVM이 OS에게서 메모리 사용권한을 할당받고 JVM이 자바프로그램을 호출하여 실행하게 된다. OS에서는 독립되었지만 JVM이라는 프로그램에 종속적이게 된다.</p>
<p><img src="https://i0.wp.com/thinkground.studio/wp-content/uploads/2020/09/200923_class-loader.png?fit=1200%2C679&amp;ssl=1" alt=""></p>
<p>Class Loader: JVM내로 클래스를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈로써 런타임시 동적으로 클래스를 로드한다.</p>
<p>Execution Engine: Class Loader를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드를 실행한다. 이 때, Execution Engine은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.</p>
<p>Garbage Collector: JVM은 Garbage Collector를 통해 메모리 관리 기능을 자동으로 수행한다. 애플리케이션이 생성한 객체의 생존 여부를 판단하여 더 이상 사용되지 않는 객체를 해제하는 방식으로 메모리를 자동 관리한다.</p>
<p>Runtime Data Areas: JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. Class
Loader에서 준비한 데이터들을 보관하는 저장소이다.</p>
<p><img src="https://velog.velcdn.com/images/rik963/post/84ef5c79-ea74-459a-8a85-391eef47246a/image.png" alt=""></p>
<p><strong>Method (Static) Area</strong>: JVM이 읽어들인 클래스와 인터페이스 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(Static 변수), 생성자와 메소드를 저장하는 공간이다.</p>
<p><strong>Runtime Constant Pool</strong></p>
<p>–       메소드 영역에 포함되지만 독자적 중요성이 있다.</p>
<p>–       클래스 파일 constant_pool 테이블에 해당하는 영역이다.</p>
<p>–       클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장한다.</p>
<p>–       JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리상 주소를 찾아 참조한다</p>
<p><img src="https://ksm0207.github.io/post/Java/memory3.png" alt=""></p>
<p>메소드 영역/런타임 상수 풀의 사용기간 및 스레드 공유 범위
–    JVM 시작시 생성
–    프로그램 종료 시까지
–    명시적으로 null 선언 시
–    구성 방식이나 GC 방법은 JVM 벤더마다 다를 수 있다.
–    모든 스레드에서 공유한다.
Heap Area
–    JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역이다.
–    New 연산자로 생성된 객체 또는 객체(인스턴스)와 배열을 저장한다.
–    힙 영역에 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
–    참조하는 변수나 필드가 없다면 의미 없는 객체가 되어 GC의 대상이 된다.
–    힙 영역의 사용기간 및 스레드 공유 범위
객체가 더 이상 사용되지 않거나 명시적으로 null 선언 시
GC(Garbage Collection) 대상
구성 방식이나 GC 방법은 JVM 벤더마다 다를 수 있다.
모든 스레드에서 공유한다.
Stack Area
–    각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다.
–    메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
–    선입후출(FILO, First In Last Out) 구조로 push와 pop 기능 사용
–    메소드 호출 시 생성되는 스레드 수행정보를 기록하는 Frame을 저장
–    메소드 정보, 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
–    기본(원시)타입 변수는 스택 영역에 직접 값을 가진다.
–    참조타임 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다.
PC Register
–    현재 수행 중인 JVM 명령 주소를 갖는다.
–    프로그램 실행은 CPU에서 인스트럭션(Instruction)을 수행.
–    CPU는 인스트럭션을 수행하는 동안 필요한 정보를 CPU 내 기억장치인 레지스터에 저장한다.
–    연산 결과값을 메모리에 전달하기 전 저장하는 CPU 내의 기억장치
Native Method Stack Area
–    자바 외 언어로 작성된 네이티브 코드를 위한 Stack이다.
–    즉, JNI(Java Native Interface)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택이다.
–    네이티브 메소드의 매개변수, 지역변수 등을 바이트 코드로 저장한다.</p>
<h3 id="-">지역변수와 전역변수</h3>
<h3 id="-">클래스</h3>
<p>자바 클래스는 객체를 정의하는 틀이나 설계도로 사용됩니다. 이 클래스를 기반으로 여러 객체를 생성하여 사용합니다. 클래스는 객체의 상태를 나타내는 <strong>필드 (field)</strong>와 객체의 동작을 나타내는 <strong>메소드 (method)</strong>로 구성됩니다. 클래스는 실체화되지 않은 추상적인 개념으로, 객체를 생성하기 위해 사용됩니다</p>
<p>클래스를 선언하고 인스턴스를 생성하는 방법은 다음과 같습니다.</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> {
    <span class="hljs-comment">// 필드 (Field)</span>
    String name; <span class="hljs-comment">// 이름</span>
    <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 나이</span>
    <span class="hljs-keyword">int</span> korean_score; <span class="hljs-comment">// 국어 성적</span>
    <span class="hljs-keyword">int</span> math_score; <span class="hljs-comment">// 수학 성적</span>
    <span class="hljs-keyword">int</span> english_score; <span class="hljs-comment">// 영어 성적</span>

    <span class="hljs-comment">// 생성자 (Constructor)</span>
    Student(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> kor_score, <span class="hljs-keyword">int</span> mat_score, <span class="hljs-keyword">int</span> eng_score) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
        <span class="hljs-keyword">this</span>.korean_score = kor_score;
        <span class="hljs-keyword">this</span>.math_score = mat_score;
        <span class="hljs-keyword">this</span>.english_score = eng_score;
    }

    <span class="hljs-comment">// 메소드 (Method)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printScore</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"이름: "</span> + name);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"나이: "</span> + age);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"국어 성적: "</span> + korean_score);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"수학 성적: "</span> + math_score);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"영어 성적: "</span> + english_score);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        <span class="hljs-comment">// 생성자가 없는 경우</span>
        Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"홍길동"</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>);
    }
}
</code></pre><p>클래스를 통해 객체를 생성할 때는 new 연산자를 사용하며, 생성자의 인자 값을 맞춰서 넣습니다. 이렇게 생성된 객체는 힙 메모리 영역에 생성되며 해당 클래스의 인스턴스라고 합니다. 클래스는 객체의 청사진이며, 인스턴스는 붕어빵 틀에서 찍어낸 붕어빵과 같습니다</p>
<h3 id="-">메서드</h3>
<p>자바에서 메소드란 코드 블록 또는 문의 집합으로, 특정 작업을 수행하기 위해 함께 그룹화된 코드입니다. 메소드는 코드의 재사용성을 달성하는 데 사용되며, 한 번 정의한 후 여러 번 호출할 수 있습니다. 이를 통해 코드를 반복해서 작성할 필요 없이 쉽게 수정하고 읽을 수 있습니다.</p>
<p>메소드는 호출할 때만 실행되며, 메서드 선언은 가시성, 반환 유형, 이름 및 인수와 같은 메서드 속성에 대한 정보를 제공합니다. 메서드 선언은 다음과 같은 구성 요소로 이루어져 있습니다:</p>
<p>가시성 (Visibility): 메소드가 어디에서 접근 가능한지를 나타냅니다. 예를 들어, public, private, protected 등이 있습니다.
반환 유형 (Return Type): 메소드가 반환하는 값의 자료형을 지정합니다. 자료형이 없는 경우 void를 사용합니다.
메소드 이름 (Method Name): 메소드를 호출할 때 사용하는 이름입니다.
인수 (Parameters): 메소드에 전달되는 입력 값입니다. 매개변수를 통해 메소드의 동작을 조절할 수 있습니다.</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title">Ex04</span>{
<span class="hljs-comment">/*
static -&gt; static        [클래스명.]메서드명();
static -&gt; non-static        참조변수.메서드명();
non-static -&gt; static        [클래스명.]메서드명();
non-static -&gt; non-static    [this.]메서드명();

*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>{
  func01();
  Ex04 me=<span class="hljs-keyword">new</span> Ex04();
  me=<span class="hljs-keyword">new</span> Ex04();
  me.func02();
}

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func01</span>(<span class="hljs-params"></span>)</span>{
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"static method func01()..."</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func02</span>(<span class="hljs-params"></span>)</span>{
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"non-static method func02()..."</span>);
    func01();
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func03</span>(<span class="hljs-params"></span>)</span>{
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"non-static method func03()..."</span>);
  }}
</code></pre><h3 id="-">오버로딩</h3>
<p>자바 오버로딩은 한 클래스 내에서 같은 이름을 가진 메소드가 있더라도, 매개변수나 타입이 다르면 같은 이름을 사용하여 메소드를 정의할 수 있는 개념입니다. 이를 통해 메서드의 이름은 같고 매개변수의 유형과 갯수는 다르게 한다면 오버로딩을 할 수 있습니다.
예를 들어, 아래와 같은 클래스가 있다고 가정해봅시다</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j</span>) </span>{
        <span class="hljs-keyword">return</span> i + j;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k</span>) </span>{
        <span class="hljs-keyword">return</span> i + j + k;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> i, <span class="hljs-keyword">double</span> j</span>) </span>{
        <span class="hljs-keyword">return</span> i + j;
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>) </span>{
    Test3 a = <span class="hljs-keyword">new</span> Test3();
    <span class="hljs-keyword">int</span> i = a.Test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">int</span> j = a.Test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">int</span> k = a.Test(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>);
}
</code></pre><p>위의 코드에서 Test라는 이름을 가진 함수를 호출했을 때, 매개변수의 유형에 따라 호출되는 메소드가 다르게 됩니다. 이렇게 오버로딩을 사용하면 동일한 이름의 메소드를 중복 작성하여 사용의 편리성과 다형성을 실현할 수 있습니다12.</p>
<p>오버로딩의 성립 조건과 특징은 다음과 같습니다:</p>
<pre><code>메서드 이름이 같아야 합니다.
매개변수 유형 <span class="hljs-comment">(타입)</span>이나 갯수 <span class="hljs-comment">(파라미터)</span>나 순서가 달라야 합니다.
굳이 반환값을 통일하지 않아도 됩니다. <span class="hljs-comment">(즉, 리턴타입, 리턴값과는 무관하다!)</span><span class="hljs-number">13</span>
</code></pre><h3 id="-">동적파라미터</h3>
<p>자바에서 동적으로 파라미터를 다루는 방법 중 하나는 <strong>가변인자 (varargs)</strong>를 활용하는 것입니다. 가변인자를 사용하면 메소드에 동적으로 여러 개의 파라미터를 전달할 수 있습니다. 사용법은 변수 타입 뒤에 기호 ...를 붙여주면 됩니다. 가변인자를 가지고 있는 메소드를 호출할 때는 다음과 같은 방법을 사용할 수 있습니다.
가변인자 코드</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printValues</span>(<span class="hljs-params">String... values</span>) </span>{
    <span class="hljs-keyword">for</span> (String <span class="hljs-keyword">value</span> : values) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">value</span>);
    }
}

<span class="hljs-comment">// 호출 예시</span>
printValues(<span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Cherry"</span>);

배열 사용 코드
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span>(<span class="hljs-params">String[] values</span>) </span>{
    <span class="hljs-keyword">for</span> (String <span class="hljs-keyword">value</span> : values) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">value</span>);
    }
}

<span class="hljs-comment">// 호출 예시</span>
String[] fruits = {<span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Cherry"</span>};
printArray(fruits);
</code></pre><pre><code>자바 내부에서는 배열의 활용하므로 배열을 활용하는 방법과 동일하며
주의 할 점으로는 <span class="hljs-selector-tag">JDK1</span><span class="hljs-selector-class">.5</span>부터 지원하는 문법이며 다른 매개변수가 더 있다면 가변인자는 마지막에 선언되어야 합니다.
</code></pre><h3 id="-">생성자</h3>
<p>자바 생성자는 인스턴스가 생성될 때 호출되는 <strong>“인스턴스 변수 초기화 메소드”</strong>입니다. 이를 통해 인스턴스 변수의 초기화 작업을 수행하며, 인스턴스가 생성될 때 실행되어야 하는 작업을 위해서도 사용됩니다.</p>
<p>생성자는 클래스의 인스턴스를 초기화하고 설정하는 데 사용됩니다. 기본 생성자(default constructor)는 클래스의 인스턴스를 초기화하지 않고 설정할 수 있습니다. 객체를 생성할 때 메모리가 할당되고, 생성자를 호출하여 객체를 초기화합니다. Java 컴파일러는 클래스에 사용 가능한 생성자가 없는 경우 기본 생성자를 제공합니다.</p>
<p>생성자는 클래스 설계와 객체 생성에 중요한 역할을 합니다. 예를 들어, 얼굴이라는 클래스로 얼굴 객체를 만들 때, 생성자를 호출하여 얼굴의 각 부위를 초기화하고 화장을 하게 됩니다. 이를 통해 서로 다른 모양의 얼굴 객체를 생성할 수 있습니다.</p>
<p>자바에서는 두 가지 유형의 생성자가 있습니다:</p>
<p>매개 변수화된 생성자: 매개 변수를 받아 객체를 초기화하는 생성자입니다.
no-arg 생성자: 매개 변수 없이 객체를 초기화하는 생성자입니다.
생성자는 객체 생성 시 값을 구성하기 때문에 그 이름이 붙여졌습니다. 자바에서는 생성자를 통해 객체를 초기화하고 설정하는데 활용합니다.</p>
<h3 id="this-super">this 와 super</h3>
<p>자바에서 this와 super는 객체 지향 프로그래밍에서 주로 사용되는 키워드입니다. 이 두 키워드의 차이점을 살펴보겠습니다: </p>
<p><code>this</code>:
this는 현재 클래스의 인스턴스를 가리키는 참조변수입니다. 
주로 동일한 클래스 내에서 정의된 변수를 식별할 때 사용됩니다. 
예를 들어, 클래스 내에 동일한 이름의 멤버 변수가 있을 때 this.var를 사용하여 클래스 영역에 정의된 변수를 참조할 수 있습니다. 
또한 this()를 사용하여 같은 클래스의 다른 생성자를 호출할 수 있습니다. </p>
<p><code>super</code>: 
super는 부모 클래스를 가리키는 참조변수입니다. 
주로 상속 관계에서 부모 클래스의 변수나 메서드를 호출할 때 사용됩니다. 
만약 부모 클래스와 자식 클래스에서 동일한 이름의 변수나 메서드가 있을 때, super를 사용하여 부모 클래스의 멤버를 구분할 수 있습니다. 
또한 super()를 사용하여 부모 클래스의 기본 생성자를 호출할 수 있습니다. 
간단한 예시를 통해 이해해보겠습니다: </p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> {
    String <span class="hljs-keyword">var</span>;

    Parent() {
        <span class="hljs-keyword">var</span> = <span class="hljs-string">"생성자도 물려주지 않는다."</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">method</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y</span>) </span>{
        <span class="hljs-keyword">return</span> x + y;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-title">extends</span> <span class="hljs-title">Parent</span> {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">childMethod</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">var</span>); <span class="hljs-comment">// 부모 클래스에서 상속받은 String var</span>
        System.<span class="hljs-keyword">out</span>.println(method(<span class="hljs-number">7</span>, <span class="hljs-number">13</span>)); <span class="hljs-comment">// 부모 클래스에서 상속받은 int method()를 오버라이딩한 것</span>
    }

    @<span class="hljs-function">Override
    <span class="hljs-keyword">int</span> <span class="hljs-title">method</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y</span>) </span>{
        <span class="hljs-keyword">return</span> x * y;
    }

    <span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span>; <span class="hljs-comment">// 인스턴스 변수</span>

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> <span class="hljs-keyword">var</span></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">var</span>); <span class="hljs-comment">// 입력받은 파라미터값</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">var</span>); <span class="hljs-comment">// 인스턴스 변수 int var</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">this</span>.method(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 오버라이딩한 자식 클래스 메서드</span>
        System.<span class="hljs-keyword">out</span>.println(super.method(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 부모 클래스 메서드</span>
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        Child c = <span class="hljs-keyword">new</span> Child();
        c.test(<span class="hljs-number">52</span>);
    }
}
</code></pre><pre><code><span class="hljs-number">52.0</span>
<span class="hljs-number">0</span>
<span class="hljs-number">0</span>
<span class="hljs-number">20</span>
</code></pre><p>또 다른 예시로 this()를 사용한 코드도 살펴보겠습니다: </p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SutdaCard</span> </span>{
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>;
    boolean isKwang;

    SutdaCard(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>, boolean isKwang) {
        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span>;
        <span class="hljs-keyword">this</span>.isKwang = isKwang;
    }

    SutdaCard() {
        <span class="hljs-keyword">this</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">true</span>); <span class="hljs-comment">// 같은 클래스의 다른 생성자를 호출</span>
    }

    <span class="hljs-built_in">String</span> info() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">num</span> + (isKwang ? <span class="hljs-string">"K"</span> : <span class="hljs-string">""</span>);
    }
}
</code></pre><p>이렇게 this와 super를 적절히 활용하여 클래스 간의 관계를 구분하고 초기화를 수행할 수 있습니다.</p>
<h3 id="reflection">Reflection</h3>
<p>리플렉션(Reflection)은 자바에서 런타임에 클래스의 메타데이터를 검사하고 조작할 수 있는 기능입니다. 이를 통해 클래스, 메서드, 필드, 생성자 정보를 동적으로 검색하고 사용할 수 있습니다. 리플렉션은 유연성을 제공하지만, 성능 저하와 보안 문제를 유발할 수 있으므로 주의해서 사용해야 합니다.</p>
<p>클래스 정보 가져오기:
클래스 이름을 알고 있다면 Class.forName(&quot;패키지명.클래스명&quot;)을 사용하여 해당 클래스의 정보를 가져올 수 있습니다.
예시: </p>
<pre><code><span class="hljs-keyword">Class</span> carClass = <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">"com.mycompany.Car"</span>);
</code></pre><p>메서드 호출하기:
클래스의 메서드 정보를 가져온 후 invoke()를 사용하여 메서드를 실행할 수 있습니다.
예시:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">move</span> = <span class="hljs-title">carClass</span>.<span class="hljs-title">getMethod</span><span class="hljs-params">("move")</span>;</span> 
move.invoke(obj, null);
</code></pre><p>필드 값 변경하기:
클래스의 필드 정보를 가져온 후 set()을 사용하여 필드 값을 변경할 수 있습니다.
예시: </p>
<pre><code>Field positionField = carClass.getDeclaredField(<span class="hljs-string">"position"</span>)<span class="hljs-comment">; </span>
positionField<span class="hljs-meta">.set</span>(obj, <span class="hljs-number">42</span>)<span class="hljs-comment">;</span>
</code></pre><p>생성자로 객체 생성하기:
클래스의 생성자 정보를 가져온 후 newInstance()를 사용하여 객체를 생성할 수 있습니다.
예시:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">Car</span>&gt; <span class="hljs-title">constructor</span> = <span class="hljs-title">carClass</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">(<span class="hljs-keyword">String</span>.<span class="hljs-keyword">class</span>, int.<span class="hljs-keyword">class</span>)</span>;</span> 
Car car = <span class="hljs-function"><span class="hljs-keyword">constructor</span>.<span class="hljs-title">newInstance</span><span class="hljs-params">("MyCar", 0)</span>;</span>
</code></pre><p>Reflection은 프레임워크, 라이브러리, 테스트 도구 등에서 활용되며, 일반적인 애플리케이션 개발에서는 사용하지 않는 것이 좋습니다. 성능 오버헤드와 보안적인 이슈를 고려해야 하기 때문입니다.</p>
<pre><code><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.slf4j.Logger;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.slf4j.LoggerFactory;</span>

<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.io.IOException;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.net.URL;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.Collections;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.Enumeration;</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> checkLoadedClasses() throws IOException {
        Logger logger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());
        ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();

        <span class="hljs-comment">// Check if org.slf4j.impl.StaticLoggerBinder.class is loaded</span>
        Enumeration&lt;URL&gt; resources1 = classLoader.getResources(<span class="hljs-string">"org/slf4j/impl/StaticLoggerBinder.class"</span>);
        logger.error(<span class="hljs-string">"resources1: {}"</span>, Collections.list(resources1));

        <span class="hljs-comment">// Check if com.mytest.TestClass.class is loaded (replace with your own class)</span>
        Enumeration&lt;URL&gt; resources2 = classLoader.getResources(<span class="hljs-string">"com/mytest/TestClass.class"</span>);
        logger.error(<span class="hljs-string">"resources2: {}"</span>, Collections.list(resources2));

        <span class="hljs-comment">// Check if java.net.URL.class is loaded</span>
        Enumeration&lt;URL&gt; resources3 = classLoader.getResources(<span class="hljs-string">"java/net/URL.class"</span>);
        logger.error(<span class="hljs-string">"resources3: {}"</span>, Collections.list(resources3));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) throws IOException {
        ClassLoaderTest test = <span class="hljs-keyword">new</span> ClassLoaderTest();
        test.checkLoadedClasses();
    }
}
</code></pre><h3 id="-">상속</h3>
<h4 id="-">클래스의 상속</h4>
<p>상속은 객체지향 프로그래밍에서 중요한 개념입니다. 이를 통해 클래스 간에 코드를 재사용하고 중복을 최소화할 수 있습니다. 상속을 사용하는 주요 이유는 다음과 같습니다:</p>
<p>코드 재사용:
이미 작성된 클래스를 확장하여 새로운 클래스를 만들 수 있습니다.
부모 클래스의 멤버(필드, 메서드)를 자식 클래스에서 그대로 사용할 수 있습니다.</p>
<p>계층 구조:
상속을 통해 클래스 간에 계층 구조를 만들 수 있습니다.
부모 클래스를 일반화하고, 자식 클래스를 특수화하여 프로그램의 구조를 체계적으로 설계할 수 있습니다.</p>
<p>중복 코드 최소화:
공통된 기능을 부모 클래스에 구현하면, 자식 클래스에서 해당 기능을 반복해서 작성할 필요가 없습니다. 
이로써 코드 중복을 줄이고 유지보수성을 향상시킬 수 있습니다.</p>
<p>다형성 지원:
상속을 통해 다형성을 구현할 수 있습니다.
부모 클래스 타입으로 자식 클래스의 객체를 다룰 수 있어 유연한 프로그래밍이 가능합니다.</p>
<p>상속은 프로그램의 구조를 더 명확하게 만들고, 코드를 효율적으로 관리할 수 있도록 도와줍니다.
클래스 간의 상속은 extends 키워드를 사용하여 선언합니다. 상속을 통해 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있습니다. 아래 예시를 통해 상속의 개념과 사용법을 살펴보겠습니다.</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> {
    <span class="hljs-comment">// 필드</span>
    String name; <span class="hljs-comment">// 이름</span>
    <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 나이</span>

    <span class="hljs-comment">// 메소드</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMyself</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"이름: "</span> + name);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"나이: "</span> + age);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">extends</span> <span class="hljs-title">People</span> {
    <span class="hljs-comment">// 추가 필드</span>
    <span class="hljs-keyword">int</span> koreanScore; <span class="hljs-comment">// 국어 성적</span>
    <span class="hljs-keyword">int</span> mathScore; <span class="hljs-comment">// 수학 성적</span>
    <span class="hljs-keyword">int</span> englishScore; <span class="hljs-comment">// 영어 성적</span>

    <span class="hljs-comment">// 생성자</span>
    Student(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> koreanScore, <span class="hljs-keyword">int</span> mathScore, <span class="hljs-keyword">int</span> englishScore) {
        super.name = name; <span class="hljs-comment">// 부모 클래스의 필드</span>
        super.age = age; <span class="hljs-comment">// 부모 클래스의 필드</span>
        <span class="hljs-keyword">this</span>.koreanScore = koreanScore;
        <span class="hljs-keyword">this</span>.mathScore = mathScore;
        <span class="hljs-keyword">this</span>.englishScore = englishScore;
    }

    <span class="hljs-comment">// 추가 메소드</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printScore</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"국어 성적: "</span> + koreanScore);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"수학 성적: "</span> + mathScore);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"영어 성적: "</span> + englishScore);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"홍길동"</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>);
        student.printMyself(); <span class="hljs-comment">// 부모 메소드 호출</span>
        student.printScore(); <span class="hljs-comment">// 자식 메소드 호출</span>
    }}
</code></pre><p>위 예시에서 Student 클래스는 People 클래스를 상속받았습니다. Student 클래스는 부모 클래스인 People의 필드와 메소드를 사용할 수 있으며, 추가적으로 자신만의 필드와 메소드를 정의할 수 있습니다. 상속을 통해 코드를 재사용하고 중복을 최소화할 수 있습니다</p>
<h4 id="-">인터페이스</h4>
<p>인터페이스의 상속에는 implements 키워드가 사용된다
다중 상속이 허용됨
객체 생성불가(객체생성 대상은 클래스)
상수형 변수만을 갖는다 - final 생략가능, static 생략가능
접근제한자는 오직 public만 갖는다 - public 생략가능
추상메서드만을 갖는다 - abstract 생략가능
인터페이스간의 상속은 extends 키워드를 사용</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lec08</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> su1=<span class="hljs-number">1111</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> su2=<span class="hljs-number">2222</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> su3=<span class="hljs-number">3333</span>;
    <span class="hljs-keyword">int</span> su4=<span class="hljs-number">4444</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func01</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func03</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func04</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lec888</span></span>{}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lec88</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Lec08</span>,<span class="hljs-title">Lec888</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func03</span><span class="hljs-params">()</span></span>;}
</code></pre><h4 id="-">디폴트 메서드</h4>
<p>디폴트 메서드란? 인터페이스에 선언된 메서드 중, default 키워드를 사용하여 실제 구현을 포함할 수 있는 메서드입니다.
디폴트 메서드(Default Method)는 자바 8에서 도입된 기능으로, 인터페이스(Interface)에서 메타데이터를 검사하고 조작할 수 있게 해줍니다. 이를 통해 클래스, 메서드, 필드, 생성자 정보를 동적으로 검색하고 사용할 수 있습니다. 디폴트 메서드는 유연성을 제공하지만, 성능 저하와 보안 문제를 유발할 수 있으므로 주의해서 사용해야 합니다.</p>
<p>디폴트 메서드를 사용하는 이유는 다음과 같습니다:</p>
<p>기존 인터페이스 확장:
기존 인터페이스에 새로운 메서드를 추가하면 모든 구현체에서 해당 메서드를 구현해야 했습니다.
디폴트 메서드를 사용하면 인터페이스에 기본 구현을 제공할 수 있어, 기존 코드를 변경하지 않고도 새로운 기능을 확장할 수 있습니다.
소스 호환성 유지:
라이브러리 설계자가 API를 변경하면서도 기존 버전과의 호환성을 유지할 수 있습니다.
디폴트 메서드를 이용하여 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있습니다.
다중 상속 지원:
디폴트 메서드를 통해 다중 상속 동작을 지원할 수 있습니다.
여러 인터페이스에서 동일한 메서드를 제공할 때 충돌을 방지하고 해결할 수 있습니다.</p>
<p>디폴트 메서드는 프로그램이 자신의 클래스, 필드, 메서드, 생성자 등에 대한 정보를 동적으로 얻을 수 있게 해주며, 이를 통해 해당 클래스 또는 객체를 조작하거나 실행할 수 있습니다. 하지만 성능 저하와 보안 취약성에 주의하여 사용해야 합니다.
예시로, 아래 코드는 디폴트 메서드를 사용한 인터페이스와 클래스의 예시입니다</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethodA</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethodB</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethodA</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Hello from defaultMethodA"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        MyClass myClass = <span class="hljs-keyword">new</span> MyClass();
        myClass.abstractMethodA(); <span class="hljs-comment">// Implement this method</span>
        myClass.abstractMethodB(); <span class="hljs-comment">// Implement this method</span>
        myClass.defaultMethodA(); <span class="hljs-comment">// Use the default implementation</span>
    }
}
</code></pre><p>디폴트 메서드 defaultMethodA는 인터페이스 MyInterface에 기본 구현으로 제공되며, MyClass에서는 해당 메서드를 직접 구현하지 않아도 사용할 수 있습니다.</p>
<h3 id="-">다형성</h3>
<p>다형성(Polymorphism)은 객체지향 프로그래밍에서 중요한 개념입니다. 이를 통해 같은 자료형에 여러 가지 객체를 대입하여 다양한 결과를 얻어낼 수 있습니다. 다형성은 다양한 형태를 가질 수 있는 능력을 의미하며, 객체를 부품화하여 유지 보수를 용이하게 합니다.
자바에서 다형성을 구현하는 데 사용되는 주요 키워드와 개념은 다음과 같습니다.</p>
<p>상속 (Inheritance):
클래스 간의 상속을 통해 다형성을 구현할 수 있습니다.
부모 클래스의 멤버를 자식 클래스에서 상속받아 사용합니다.</p>
<p>메서드 오버라이딩 (Method Overriding):
자식 클래스에서 부모 클래스의 메서드를 재정의하는 것입니다.
동일한 메서드 시그니처를 가진 자식 클래스의 메서드가 부모 클래스의 메서드를 대체합니다.</p>
<p>업캐스팅 (Upcasting):
자식 클래스의 객체를 부모 클래스 타입으로 참조하는 것입니다.
다형성을 활용하여 여러 타입의 객체를 하나의 변수로 다룰 수 있습니다.</p>
<p>인터페이스 (Interface):
인터페이스를 구현한 클래스들은 같은 인터페이스 타입으로 다룰 수 있습니다.
인터페이스를 통해 다형성을 구현할 수 있습니다.</p>
<p>다형성 (Polymorphism):
다양한 형태를 가진 객체를 동일한 타입으로 다루는 능력입니다.
상속, 메서드 오버라이딩, 업캐스팅, 인터페이스를 통해 다형성을 실현할 수 있습니다.</p>
<p>이러한 키워드와 개념을 활용하여 자바에서 다형성을 구현할 수 있습니다</p>
<pre><code>package app;
<span class="hljs-comment">// 다형성</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title">Machine</span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">on</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">off</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span> <span class="hljs-title">implements</span> <span class="hljs-title">Machine</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"켜다"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"끄다"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"방송 주파수를 잡아 화면과 소리를 출력해준다"</span>);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Radio</span> <span class="hljs-title">implements</span> <span class="hljs-title">Machine</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"켜다"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"끄다"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"주파수를 잡아 소리를 들려준다"</span>);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Audio</span> <span class="hljs-title">implements</span> <span class="hljs-title">Machine</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"켜다"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"끄다"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"음악을 들려준다"</span>);
    }
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        java.util.Scanner sc;
        sc=<span class="hljs-keyword">new</span> java.util.Scanner(System.<span class="hljs-keyword">in</span>);
        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">"1.tv 2.radio 3.audio&gt;"</span>);
        <span class="hljs-keyword">int</span> input=sc.nextInt();
        Machine remote;
        <span class="hljs-keyword">if</span>(input==<span class="hljs-number">1</span>) {
            remote=<span class="hljs-keyword">new</span> Tv();
        }<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span>(<span class="hljs-params">input==<span class="hljs-number">2</span></span>)</span>{
            remote=<span class="hljs-keyword">new</span> Radio();
        }<span class="hljs-keyword">else</span> {
            remote=<span class="hljs-keyword">new</span> Audio();
        }
        remote.<span class="hljs-keyword">on</span>();
        remote.work();
        remote.off();
    }
}
</code></pre><h3 id="-">예외처리</h3>
<p>자바에서 예외 처리는 프로그램 실행 중 발생할 수 있는 예외적인 상황을 관리하고, 프로그램의 안정성을 유지하기 위한 중요한 기능입니다. 예외 처리를 위해 주로 try, catch, finally 블록을 사용합니다. 다음은 자바에서 예외 처리를 하는 기본적인 방법입니다:</p>
<pre><code><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 예외가 발생할 수 있는 코드</span>
} <span class="hljs-keyword">catch</span> (ExceptionType name) {
    <span class="hljs-comment">// ExceptionType 예외가 발생했을 때 처리할 코드</span>
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 예외 발생 여부와 관계없이 실행되는 코드</span>
}
</code></pre><p>try 블록: 예외가 발생할 가능성이 있는 코드를 포함합니다.
catch 블록: 특정 예외가 발생했을 때 그 예외를 처리하는 코드를 포함합니다. 여러 개의 catch 블록을 사용하여 다양한 예외를 처리할 수 있습니다.
finally 블록: 예외 발생 여부와 관계없이 실행되어야 하는 코드를 포함합니다. 주로 자원을 해제하거나 정리하는 코드를 작성합니다.
예외 클래스는 프로그램 실행 중에 발생할 수 있는 예외적인 상황을 처리하기 위해 사용됩니다. 예외 클래스는 java.lang.Exception 클래스를 상속받아 생성되며, 두 가지 주요 유형으로 나뉩니다:</p>
<p> <strong>체크 예외(checked exceptions)</strong>와 언체크 예외(unchecked exceptions).</p>
<p>체크 예외: 컴파일 시점에 체크되는 예외로, 개발자가 명시적으로 처리해야 합니다. 예를 들어, IOException이 이에 해당합니다.
언체크 예외: 런타임 시점에 발생하는 예외로, 주로 프로그램의 버그 때문에 발생합니다. 예를 들어, NullPointerException이 이에 해당합니다.
예외 처리를 위해 try-catch 블록을 사용하거나, 예외를 메소드의 호출자에게 전파하기 위해 throws 키워드를 사용할 수 있습니다. 또한, 특정 상황에 맞는 예외를 정의하기 위해 사용자 정의 예외 클래스를 만들 수도 있습니다. 사용자 정의 예외 클래스는 Exception 클래스나 RuntimeException 클래스를 상속받아 구현할 수 있습니다.</p>
<p>다음은 사용자 정의 예외 클래스의 간단한 예시입니다:</p>
<pre><code>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>{
    public <span class="hljs-type">MyCustomException</span>(<span class="hljs-type">String</span> message) {
        <span class="hljs-keyword">super</span>(message);
    }
}

<span class="hljs-comment">// 사용 예</span>
public void myMethod() <span class="hljs-keyword">throws</span> <span class="hljs-type">MyCustomException</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyCustomException</span>(<span class="hljs-string">"Custom error occurred"</span>);
}
</code></pre><p>위 코드에서 MyCustomException은 사용자 정의 예외 클래스로, Exception 클래스를 상속받아 만들어졌습니다. myMethod 메소드는 이 예외를 발생시키며, 이 메소드를 호출하는 코드는 try-catch 블록으로 이 예외를 처리하거나, 다시 throws를 통해 전파해야 합니다.</p>
<h3 id="-">내부클래스</h3>
<p>내부 클래스(inner class)란<br>하나의 <strong><u>클래스 내부에 선언된 또 다른 클래스</u></strong>를 의미</p>
<table>
<thead>
<tr>
<th><strong>내부 클래스</strong></th>
<th><strong>특징</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>인스턴스 클래스 <br> (instance class)</td>
<td>외부 클래스의 멤버변수 선언 위치에 선언하며, 외부 클래스의 인스턴스 멤버처럼 다뤄진다.<br> 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.</td>
</tr>
<tr>
<td>스태틱 클래스 <br> (static class)</td>
<td>외부 클래스의 멤버변수 선언 위치에 선언하며, 외부 클래스의 static 멤버처럼 다뤄진다.<br> 다만 주의할점은 static이라고 해서 new 생성자 초기화를 못하는 건 아니다.<br> 즉, 일반적인 static 필드 변수나 static 메서드와 달리, staic 내부 클래스는 같은 static이지만 메모리 구조나 기능이 전혀 다르다.</td>
</tr>
<tr>
<td>지역 클래스 <br> (local class)</td>
<td>외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 메서드 블록 영역 내부에서만 사용될 수 있다.</td>
</tr>
<tr>
<td>익명 클래스 <br> (anonymous class)</td>
<td>클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스이다. 주로 클래스를 일회용으로 사용할때 자주 이용된다.</td>
</tr>
</tbody>
</table>
<pre><code>day01;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex01</span> {
    <span class="hljs-comment">//1.스태틱 [멤버]클래스</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Inner01</span>{}
    <span class="hljs-comment">// 2.인스턴스 [멤버]클래스</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title">Inner02</span>{}

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// 3.로컬클래스</span>
        <span class="hljs-keyword">class</span> <span class="hljs-title">Inner03</span>{}
        <span class="hljs-comment">// 4.anonymous 클래스</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        <span class="hljs-comment">// 내부클래스 - 4가지 종류</span>

    }
}
</code></pre><pre><code>package day01;

<span class="hljs-keyword">class</span> <span class="hljs-title">Outter04</span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> su1=<span class="hljs-number">1111</span>;
    <span class="hljs-keyword">int</span> su2=<span class="hljs-number">2222</span>;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func01</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">class</span> <span class="hljs-title">Loc01</span>{
            final <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> su3=<span class="hljs-number">3333</span>;
            <span class="hljs-keyword">int</span> su4=<span class="hljs-number">4444</span>;
            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func02</span>(<span class="hljs-params"></span>) </span>{
                System.<span class="hljs-keyword">out</span>.println(su1);
                func01();
                Outter04 outt=<span class="hljs-keyword">new</span> Outter04();
                System.<span class="hljs-keyword">out</span>.println(outt.su2);
                outt.func02();
            }
        }
        Loc01 loc=<span class="hljs-keyword">new</span> Loc01();
        System.<span class="hljs-keyword">out</span>.println(loc.su4);
        loc.func02();
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func02</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">int</span> su5=<span class="hljs-number">5555</span>; <span class="hljs-comment">// jdk1.8~ final키워드 생략가능</span>
        <span class="hljs-keyword">class</span> <span class="hljs-title">Loc02</span>{
            final <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> su3=<span class="hljs-number">3333</span>;
            <span class="hljs-keyword">int</span> su4=<span class="hljs-number">4444</span>;
            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func02</span>(<span class="hljs-params"></span>) </span>{
                System.<span class="hljs-keyword">out</span>.println(su5);
                func01();
                System.<span class="hljs-keyword">out</span>.println(su2);
                func02();
            }
        }
        System.<span class="hljs-keyword">out</span>.println(su5);
        System.<span class="hljs-keyword">out</span>.println(Loc02.su3);
        Loc02 loc=<span class="hljs-keyword">new</span> Loc02();
        System.<span class="hljs-keyword">out</span>.println(loc.su4);
        loc.func02();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex82</span> {

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{


    }
}
</code></pre><pre><code>package day01;

<span class="hljs-keyword">interface</span> <span class="hljs-title">Inter</span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lec05</span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func02</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"추상클래스의 기능"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span>;
}
<span class="hljs-keyword">class</span> <span class="hljs-title">Lec55</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"본래 기능"</span>);
    };
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Outter05</span>{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func01</span>(<span class="hljs-params"></span>) </span>{
        Lec55 obj=<span class="hljs-keyword">new</span> Lec55(){
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"익명클래스만들기"</span>);
            }
        };
        obj.func();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex83</span> {

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        Outter05.func01();
    }
}
</code></pre><h2 id="2-">2일차</h2>
<h3 id="-">제네릭</h3>
<p>제네릭(Generic)은 자바에서 소스 코드 컴파일 시 타입을 체크해주는 기능입니다. 주로 여러 가지 타입을 다루는 클래스나 메서드에 적용하여 사용합니다. 제네릭을 사용해야 하는 이유는 다음과 같습니다:</p>
<p>타입 안정성(Type Safety):
제네릭을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있습니다.
실행 시 타입 에러가 나는 것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 것이 좋습니다.</p>
<p>코드 재사용 및 유지보수성:
제네릭을 활용하면 타입 변환을 최소화하고 코드를 재사용할 수 있습니다.
유지보수성을 향상시킬 수 있습니다.
제네릭의 사용법과 예시를 살펴보겠습니다:</p>
<p>제네릭 클래스:
클래스를 설계할 때 구체적인 타입을 명시하지 않고 타입 파라미터로 넣어두었다가 실제 사용될 때 구체적인 타입을 지정합니다.
예시:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExClassGeneric</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">private</span> T t;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setT</span><span class="hljs-params">(T t)</span> </span>{
        <span class="hljs-keyword">this</span>.t = t;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getT</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> t;
    }
}
</code></pre><p>제네릭 인터페이스:
인터페이스도 제네릭으로 설정해두고 활용할 수 있습니다.
예시:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExInterfaceGeneric</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-function">T <span class="hljs-title">example</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExGeneric</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExInterfaceGeneric</span>&lt;<span class="hljs-title">String</span>&gt; </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">example</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre><p>제네릭 메서드:
메서드 내에서도 제네릭을 사용할 수 있습니다.
예시</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">M</span>&gt; </span>{
    <span class="hljs-keyword">private</span> T name;
    <span class="hljs-keyword">private</span> M age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T name, M age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> M <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(M age)</span> </span>{
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-comment">// Generic Method</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compare</span><span class="hljs-params">(People&lt;T, V&gt; p1, People&lt;T, V&gt; p2)</span> </span>{
        <span class="hljs-keyword">boolean</span> nameCompare = p1.getName().equals(p2.getName());
        <span class="hljs-keyword">boolean</span> ageCompare = p1.getAge().equals(p2.getAge());
        <span class="hljs-keyword">return</span> nameCompare &amp;&amp; ageCompare;
    }
}
</code></pre><h3 id="-api">컬렉션 API</h3>
<p>배열을 이용한 자료구조 구현 예시</p>
<pre><code><span class="hljs-keyword">package</span> day02;

<span class="hljs-keyword">public</span> class Arr {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">Object</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">void</span> removeItem(<span class="hljs-keyword">Object</span> item) {
        <span class="hljs-built_in">int</span> idx=<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; i++) {
            <span class="hljs-keyword">if</span>(arr[i]==item) {
                idx=i;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span>(idx!=<span class="hljs-number">-1</span>) {
            remove(idx);
        }
    }

    <span class="hljs-keyword">void</span> remove(<span class="hljs-built_in">int</span> idx) {
        <span class="hljs-keyword">Object</span>[] arr2=<span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[arr.length<span class="hljs-number">-1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;idx; i++) {
            arr2[i]=arr[i];
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=idx+<span class="hljs-number">1</span>; i&lt;arr.length; i++) {
            arr2[i<span class="hljs-number">-1</span>]=arr[i];
        }
        arr=arr2;
    }
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>() {
        <span class="hljs-keyword">return</span> arr.length;
    }
    <span class="hljs-keyword">Object</span> <span class="hljs-built_in">get</span>(<span class="hljs-built_in">int</span> idx) {
        <span class="hljs-keyword">return</span> arr[idx];
    }
    <span class="hljs-keyword">void</span> <span class="hljs-built_in">add</span>(<span class="hljs-keyword">Object</span> su) {
        <span class="hljs-keyword">Object</span>[] arr2=<span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[arr.length+<span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; i++) {
            arr2[i]=arr[i];
        }
        arr2[arr2.length<span class="hljs-number">-1</span>]=su;
        arr=arr2;
    }
}

<span class="hljs-keyword">public</span> class Ex01 {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) {
        Arr arr=<span class="hljs-keyword">new</span> Arr();
        arr.<span class="hljs-built_in">add</span>(<span class="hljs-number">1111</span>);
        arr.<span class="hljs-built_in">add</span>(<span class="hljs-number">2222</span>);
        arr.<span class="hljs-built_in">add</span>(<span class="hljs-number">3333</span>);
        arr.<span class="hljs-built_in">add</span>(<span class="hljs-number">4444</span>);

        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i++) {
            System.out.<span class="hljs-built_in">println</span>(arr.<span class="hljs-built_in">get</span>(i));
        }
    }
}
</code></pre><p>연결구조를 이용한 자료구조 구현 예시</p>
<pre><code>package day02;

<span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>{
    <span class="hljs-keyword">int</span> val;
    Node nxt;
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Arr2</span>{
    Node first;
    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> cnt;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> idx</span>) </span>{
        Node temp=first;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;idx; i++) {
            temp=temp.nxt;
        }
        <span class="hljs-keyword">return</span> temp.val;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> su</span>) </span>{
        cnt++;
        Node node=<span class="hljs-keyword">new</span> Node();
        node.val=su;
        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>) {
            first=node;
        }<span class="hljs-keyword">else</span> {
            Node temp=first;
            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">if</span>(temp.nxt==<span class="hljs-literal">null</span>)<span class="hljs-keyword">break</span>;
                temp=temp.nxt;
            }
            temp.nxt=node;
        }
<span class="hljs-comment">//        first.nxt=node;</span>
<span class="hljs-comment">//        first.nxt.nxt=node;</span>
<span class="hljs-comment">//        first.nxt.nxt.nxt=node;</span>
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex02</span> {

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        Arr2 arr=<span class="hljs-keyword">new</span> Arr2();
        arr.<span class="hljs-keyword">add</span>(<span class="hljs-number">1111</span>);
        arr.<span class="hljs-keyword">add</span>(<span class="hljs-number">2222</span>);
        arr.<span class="hljs-keyword">add</span>(<span class="hljs-number">3333</span>);
        arr.<span class="hljs-keyword">add</span>(<span class="hljs-number">4444</span>);

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.size(); i++) {
            System.<span class="hljs-keyword">out</span>.println(arr.<span class="hljs-keyword">get</span>(i));
        }
    }
}
</code></pre><p>ArrayList와 LinkedList의 비교</p>
<pre><code><span class="hljs-keyword">package</span> day02;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex03</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">before</span>=System.<span class="hljs-title">currentTimeMillis</span>();
        java.util.ArrayList arr=<span class="hljs-keyword">new</span> ArrayList();
        <span class="hljs-comment">//java.util.LinkedList arr=new LinkedList();</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000000</span>; i++)
        arr.add(i);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.size(); i++) {
            Object obj=arr.get(i);
        }
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">after</span>=System.<span class="hljs-title">currentTimeMillis</span>();

        System.out.println(<span class="hljs-keyword">after</span>-<span class="hljs-keyword">before</span>);

<span class="hljs-comment">//        arr.add(2222);</span>
<span class="hljs-comment">//        arr.add(3333);</span>
<span class="hljs-comment">//        arr.add(4444);</span>
<span class="hljs-comment">//        for(int i=0; i&lt;arr.size(); i++) {</span>
<span class="hljs-comment">//            int obj=(int)arr.get(i);</span>
<span class="hljs-comment">//            System.out.println(obj);</span>
<span class="hljs-comment">//        }</span>
    }
}
</code></pre><h4 id="-">선형 자료구조와 비선형 자료구조</h4>
<p>선형자료구조
선형 자료구조는 하나의 자료 뒤에 하나의 자료가 존재하는 형태의 자료 구조를 말합니다. 이는 자료들 간의 앞뒤 관계가 1:1의 선형 관계를 가지는 것을 의미합니다. 대표적인 선형 자료구조로는 배열, 리스트, 스택, 큐 등이 있습니다.</p>
<p>배열 (Array):
같은 타입의 변수들로 이루어진 유한 집합입니다.
배열 요소(element)는 배열을 구성하는 각각의 값이며, 인덱스(index)는 배열의 위치를 가리키는 숫자입니다. 인덱스는 0부터 시작합니다.
리스트 (List):
데이터 요소를 순서대로 정렬한 자료구조입니다.
연결 리스트(Linked List)와 배열 리스트(Array List)가 있으며, 각각 다양한 특성을 가지고 있습니다.
스택 (Stack):
후입선출(LIFO, Last-In-First-Out) 원칙을 따르는 자료구조입니다.
데이터를 삽입(push)하고 삭제(pop)할 수 있습니다.
큐 (Queue):
선입선출(FIFO, First-In-First-Out) 원칙을 따르는 자료구조입니다.
데이터를 삽입(enqueue)하고 삭제(dequeue)할 수 있습니다.</p>
<p>비선형 자료구조
자바에서 제공하는 기본적인 비선형 자료구조 클래스와 인터페이스에는 다음과 같은 것들이 있습니다:</p>
<p>그래프 (Graph):</p>
<ul>
<li>그래프는 정점(vertex)과 간선(edge)으로 연결되어 있는 객체 간의 관계를 표현하는 비선형 자료구조입니다.</li>
<li>자바에서는 그래프를 직접 제공하는 클래스나 인터페이스는 없지만, 그래프를 구현할 때 인접 리스트(Adjacency List)나 인접 행렬(Adjacency Matrix)을 활용하여 구현할 수 있습니다.
트리 (Tree):</li>
<li>트리는 계층적인 구조를 가지며, 부모-자식 관계로 연결된 비선형 자료구조입니다.</li>
<li>자바에서는 java.util.TreeSet과 java.util.TreeMap이 트리 기반의 자료구조를 제공합니다.
인터페이스 (Interface):</li>
<li>인터페이스는 자바에서 추상 자료형을 정의하는 방법 중 하나입니다.</li>
<li>인터페이스를 활용하여 그래프나 트리를 구현할 때, 메서드 시그니처를 정의하고 클래스에서 해당 메서드를 구현할 수 있습니다.
기타 비선형 자료구조:</li>
<li>자바에서는 그 외에도 다양한 비선형 자료구조를 구현할 수 있습니다.</li>
<li>예를 들면 힙(Heap), 그래프 탐색 알고리즘 등이 있습니다.
자바에서는 이러한 기본적인 비선형 자료구조를 활용하여 다양한 프로그램을 개발할 수 있습니다</li>
</ul>
<h4 id="list-e-">List<E></h4>
<p>순서가 있는 자료구조로 만들어진 경우는 List Interface를 구현합니다.
그리고 List Interface를 구현한 클래스들은 ArrayList, LinkedList, Vector, Stack등이 존재합니다.</p>
<p>ArrayList:
동적 배열을 사용하여 요소를 저장합니다.
인덱스를 사용하여 요소에 직접 액세스할 수 있습니다.
삽입과 삭제가 빈번하지 않은 경우에 적합합니다.(이론적)</p>
<pre><code><span class="hljs-keyword">package</span> day02;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> class Ex05 {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) {
        List list=<span class="hljs-keyword">new</span> ArrayList ();
        list.<span class="hljs-built_in">add</span>(<span class="hljs-number">1111</span>);
        list.<span class="hljs-built_in">add</span>(<span class="hljs-number">2222</span>);
        list.<span class="hljs-built_in">add</span>(<span class="hljs-number">3333</span>);
        List list2=<span class="hljs-keyword">new</span> ArrayList ();
        list2.<span class="hljs-built_in">add</span>(<span class="hljs-number">2222</span>);
        list2.<span class="hljs-built_in">add</span>(<span class="hljs-number">3333</span>);
        list2.<span class="hljs-built_in">add</span>(<span class="hljs-number">4444</span>);
<span class="hljs-comment">//        list2.removeAll(list);</span>
        list2.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5555</span>);
        <span class="hljs-keyword">Object</span>[] arr3=list2.toArray();
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;arr3.length; i++) {
            System.out.<span class="hljs-built_in">println</span>(arr3[i]);
        }
    }
}
</code></pre><p>LinkedList:
각 요소가 다음 요소와 이전 요소를 가리키는 이중 연결 리스트를 사용합니다.
삽입과 삭제가 빈번한 데이터에 적합합니다. (이론적)</p>
<pre><code><span class="hljs-keyword">package</span> day02;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-keyword">public</span> class Ex05 {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) {
        LinkedList list=<span class="hljs-keyword">new</span> LinkedList();
        list.<span class="hljs-built_in">add</span>(<span class="hljs-number">1111</span>);
        list.<span class="hljs-built_in">add</span>(<span class="hljs-number">2222</span>);
        list.<span class="hljs-built_in">add</span>(<span class="hljs-number">3333</span>);
        LinkedList list2=<span class="hljs-keyword">new</span> LinkedList();
        list2.<span class="hljs-built_in">add</span>(<span class="hljs-number">2222</span>);
        list2.<span class="hljs-built_in">add</span>(<span class="hljs-number">3333</span>);
        list2.<span class="hljs-built_in">add</span>(<span class="hljs-number">4444</span>);
<span class="hljs-comment">//        list2.removeAll(list);</span>
        list2.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5555</span>);
        <span class="hljs-keyword">Object</span>[] arr3=list2.toArray();
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;arr3.length; i++) {
            System.out.<span class="hljs-built_in">println</span>(arr3[i]);
        }
    }
}
</code></pre><p>Vector:
ArrayList와 유사한 동작을 수행하는 클래스입니다.
컬렉션 프레임워크가 자바에 포함되기 이전부터 존재하던 자료구조로 호환성이 특징입니다.</p>
<pre><code>package day02;

import java.util.<span class="hljs-built_in">Vector</span>;

public class Ex09 {

    public static void main(<span class="hljs-keyword">String</span>[] args) {
        java.util.<span class="hljs-built_in">Vector</span> <span class="hljs-built_in">vec</span>;
        <span class="hljs-built_in">vec</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>();
        <span class="hljs-built_in">vec</span>.addElement(<span class="hljs-number">1111</span>);
        <span class="hljs-built_in">vec</span>.addElement(<span class="hljs-number">2222</span>);
        <span class="hljs-built_in">vec</span>.addElement(<span class="hljs-number">3333</span>);
        <span class="hljs-built_in">vec</span>.addElement(<span class="hljs-number">4444</span>);
        <span class="hljs-built_in">vec</span>.addElement(<span class="hljs-number">5555</span>);

        <span class="hljs-keyword">System</span>.out.println(<span class="hljs-built_in">vec</span>.elementAt(<span class="hljs-number">0</span>));
        <span class="hljs-keyword">System</span>.out.println(<span class="hljs-built_in">vec</span>.elementAt(<span class="hljs-number">1</span>));
        <span class="hljs-keyword">System</span>.out.println(<span class="hljs-built_in">vec</span>.elementAt(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">System</span>.out.println(<span class="hljs-built_in">vec</span>.elementAt(<span class="hljs-number">3</span>));
        <span class="hljs-keyword">System</span>.out.println(<span class="hljs-built_in">vec</span>.elementAt(<span class="hljs-number">4</span>));
    }
}
</code></pre><p>Stack:
Vector를 상속하여 구현된 클래스입니다.
Queue가 인터페이스로 존재하는 반면, 클래스로 존재함이 특징입니다.</p>
<pre><code>package day02;

import java.util.<span class="hljs-keyword">Stack</span>;

public <span class="hljs-keyword">class</span> Ex07 {

    public static void main(String[] <span class="hljs-keyword">args</span>) {
        java.util.<span class="hljs-keyword">Stack</span> <span class="hljs-keyword">stack</span>;
        <span class="hljs-keyword">stack</span>=new <span class="hljs-keyword">Stack</span>();
        <span class="hljs-keyword">stack</span>.push(1111);
        <span class="hljs-keyword">stack</span>.push(2222);
        <span class="hljs-keyword">stack</span>.push(3333);
        <span class="hljs-keyword">stack</span>.push(4444);
        <span class="hljs-keyword">stack</span>.push(5555);

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">stack</span>.peek());
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">stack</span>.peek());
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">stack</span>.peek());
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">stack</span>.peek());
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">stack</span>.peek());
<span class="hljs-comment">//        System.out.println(stack.pop());</span>
    }
}
</code></pre><p>Queue:
대표적으로 구현된 클래스가 LinkedList 입니다.</p>
<pre><code><span class="hljs-keyword">package</span> day02;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex06</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) {
        java.util.List list;
        list=<span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();
        list=<span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>();
        java.util.Queue que;
        que=<span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>();
        que.offer(<span class="hljs-number">1111</span>);
        que.offer(<span class="hljs-number">2222</span>);
        que.offer(<span class="hljs-number">3333</span>);
        que.offer(<span class="hljs-number">4444</span>);
        <span class="hljs-keyword">while</span>(que.peek()!=<span class="hljs-literal">null</span>) {
            System.out.println(que.peek());
            que.poll();
        }
<span class="hljs-comment">//        while(que.peek()!=null) {</span>
<span class="hljs-comment">//            System.out.println(que.poll());</span>
<span class="hljs-comment">//        }</span>

<span class="hljs-comment">//        que.poll();</span>
<span class="hljs-comment">//        System.out.println(que.peek());</span>
<span class="hljs-comment">//        System.out.println(que.peek());</span>
<span class="hljs-comment">//        System.out.println(que.peek());</span>
<span class="hljs-comment">//        System.out.println(que.poll());</span>
<span class="hljs-comment">//        System.out.println(que.poll());</span>
<span class="hljs-comment">//        System.out.println(que.poll());</span>
<span class="hljs-comment">//        System.out.println(que.poll());</span>
<span class="hljs-comment">//        System.out.println(que.poll());</span>
    }
}
</code></pre><h4 id="set-e-">Set<E></h4>
<p>집합처럼 중복되지 않는 원소들의 모음을 만들 수 있는 자료구조를 Set이라고 합니다.
HashSet과 TreeSet은 모두 자바에서 키(key)와 값을 연결하는 데이터 구조를 나타내는 클래스입니다. 그러나 두 클래스 사이에 중요한 차이점이 있습니다:</p>
<p>정렬 여부:</p>
<ul>
<li>HashSet: 저장 순서가 유지되지 않으며, 중복을 허용하지 않습니다.</li>
<li>TreeSet: 이진 탐색 트리(Red-Black Tree)의 형태로 데이터를 저장하며, 오름차순으로 자동 정렬됩니다.
성능:</li>
<li>HashSet: 데이터 추가, 삭제에는 빠르지만 검색과 정렬에서는 느립니다.</li>
<li>TreeSet: 데이터 추가, 삭제에는 시간이 더 걸리지만 검색과 정렬에서 뛰어납니다.</li>
</ul>
<pre><code>package day02;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex11</span> {

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        <span class="hljs-comment">// 순서가 없는 자료구조 - 집합</span>
        <span class="hljs-comment">// 1.중복을 허용하지 않는다</span>
        <span class="hljs-comment">// 2.순서o</span>


        java.util.Set set1;
        set1=<span class="hljs-keyword">new</span> java.util.HashSet();
        set1.<span class="hljs-keyword">add</span>(<span class="hljs-string">"첫번째"</span>);
        set1.<span class="hljs-keyword">add</span>(<span class="hljs-string">"두번째"</span>);
        set1.<span class="hljs-keyword">add</span>(<span class="hljs-string">"세번째"</span>);
        set1.<span class="hljs-keyword">add</span>(<span class="hljs-string">"네번째"</span>);
        set1.<span class="hljs-keyword">add</span>(<span class="hljs-string">"다섯번째"</span>);

        System.<span class="hljs-keyword">out</span>.println(set1.<span class="hljs-keyword">remove</span>(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"첫번째"</span>)));
        java.util.Iterator ite;
        ite=set1.iterator();
        <span class="hljs-keyword">while</span>(ite.hasNext()) {
            System.<span class="hljs-keyword">out</span>.println(ite.next());
        }
<span class="hljs-comment">//        Object[] arr=set1.toArray();</span>
<span class="hljs-comment">//        for(int i=0; i&lt;arr.length; i++) {</span>
<span class="hljs-comment">//            System.out.println(arr[i]);</span>
<span class="hljs-comment">//        }</span>
    }
}
</code></pre><h4 id="map-k-v-">Map<K,V></h4>
<p>Map은 다른 언어에서는 Associated Array, Dictionary, Symbol Table 등으로 부르기도 합니다.</p>
<ul>
<li>HashMap – key값의 해쉬값으로 entry를 찾아 데이터에 접급</li>
<li>TreeMap – key값을 기준으로 node의 위치를 재배치하며 저장, Red-Break Tree라는 자료구조</li>
<li>Hashtable – HashMap과 동일한 key값 연결기반 데이터 구조, 차이점은
동기화(Synchronization):</li>
<li>Hashtable은 동기화되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있습니다.</li>
<li>HashMap은 비동기적이므로 멀티스레드 환경에서 동시 접근 시 동기화를 직접 처리해야 합니다.
null 허용 여부:</li>
<li>Hashtable은 null 키를 허용하지 않습니다.</li>
<li>HashMap은 하나의 null 키와 임의의 수의 null 값을 허용합니다.</li>
<li>LinkedHashMap – HashMap를 상속하여 구현되어 거의 동일하나 입력순서에 따라 key의 순서가 보장</li>
</ul>
<pre><code>package day02;

<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.Map.Entry;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MapTest {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) {
        <span class="hljs-comment">// map - key:val쌍으로 </span>
        Map <span class="hljs-built_in">map</span>=<span class="hljs-keyword">new</span> TreeMap();
        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"key1"</span>,<span class="hljs-string">"key1"</span>);
        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"key2"</span>,<span class="hljs-number">1234</span>);
        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"key3"</span>,<span class="hljs-string">'a'</span>);
        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"key4"</span>,true);
        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"key5"</span>,null);

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"size:"</span>+<span class="hljs-built_in">map</span>.<span class="hljs-built_in">size</span>());

        Collection list = <span class="hljs-built_in">map</span>.values();
        Iterator ite=list.iterator();
        <span class="hljs-built_in">while</span>(ite.hasNext())
            System.out.<span class="hljs-built_in">println</span>(ite.next());

<span class="hljs-comment">//        Set entrys=map.entrySet();</span>
<span class="hljs-comment">//        Iterator ite=entrys.iterator();</span>
<span class="hljs-comment">//        while(ite.hasNext()) {</span>
<span class="hljs-comment">//            java.util.Map.Entry entry;</span>
<span class="hljs-comment">//            entry=(Entry) ite.next();</span>
<span class="hljs-comment">//            System.out.println(entry.getKey()</span>
<span class="hljs-comment">//                    +":"+entry.getValue());</span>
<span class="hljs-comment">//        }</span>

<span class="hljs-comment">//        Set keys=map.keySet();</span>
<span class="hljs-comment">//        Iterator ite=keys.iterator();</span>
<span class="hljs-comment">//        while(ite.hasNext()) {</span>
<span class="hljs-comment">//            Object key=ite.next();</span>
<span class="hljs-comment">//            System.out.print(key);</span>
<span class="hljs-comment">//            System.out.print(":");</span>
<span class="hljs-comment">//            System.out.println(map.get(key));</span>
<span class="hljs-comment">//        }</span>
    }
}
</code></pre><h3 id="iterating">Iterating</h3>
<p>Iterator 인터페이스는 컬렉션 프레임워크에서 저장된 요소를 읽어오는 방법을 표준화하기 위한 역할을 합니다. 이 인터페이스는 주로 읽기 전용으로 사용되며, hasNext()와 next()라는 두 가지 주요 메소드를 제공합니다. hasNext() 메소드는 다음 요소가 있는지 확인하고, next() 메소드는 다음 요소를 반환합니다.</p>
<p>Iterator 인터페이스는 Collection의 하위 컬렉션들이 소유하고 있으며, 이 컬렉션들은 Iterator 타입의 객체를 반환하는 메소드를 이미 구현하고 있습니다. 예를 들어, List와 Set 계열의 컬렉션들은 Iterator 인터페이스를 구현하지만, Map 계열은 별도의 방법을 사용합니다.</p>
<p>Iterator 인터페이스의 구현 예시는 다음과 같습니다:</p>
<pre><code><span class="hljs-comment">// Vector 컬렉션의 Iterator 사용 예</span>
<span class="hljs-built_in">Vector</span>&lt;Integer&gt; <span class="hljs-built_in">vec</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>&lt;&gt;();
<span class="hljs-built_in">vec</span>.add(<span class="hljs-number">1</span>);
<span class="hljs-built_in">vec</span>.add(<span class="hljs-number">2</span>);
<span class="hljs-built_in">vec</span>.add(<span class="hljs-number">3</span>);

Iterator&lt;Integer&gt; it = <span class="hljs-built_in">vec</span>.iterator();
<span class="hljs-keyword">while</span> (it.hasNext()) {
    Integer number = it.next();
    <span class="hljs-keyword">System</span>.out.println(number);
}
</code></pre><p>이 코드는 Vector 컬렉션에 숫자를 추가하고, iterator() 메소드를 사용하여 Iterator 객체를 생성한 다음, hasNext()와 next() 메소드를 사용하여 모든 요소를 출력합니다.</p>
<p>개선된 루프문, 즉 &quot;향상된 for문&quot;은 컬렉션과 배열을 더 쉽게 순회할 수 있도록 도와줍니다. 이 문법은 다음과 같이 사용됩니다:</p>
<pre><code><span class="hljs-keyword">for</span> (타입 변수명 : 배열 또는 컬렉션) {
    <span class="hljs-comment">// 반복 실행할 코드</span>
}
</code></pre><p>ListIterator<E> 인터페이스는 주로 List 인터페이스를 구현한 클래스들에 의해 구현됩니다. 이러한 클래스들은 다음과 같습니다:</p>
<ul>
<li>ArrayList: 가장 널리 사용되는 List 구현체 중 하나로, 배열 기반의 데이터 구조를 가지고 있습니다.</li>
<li>LinkedList: 이중 연결 리스트 기반의 List 구현체로, 요소의 삽입과 삭제가 빈번할 때 유용합니다.</li>
<li>Vector: ArrayList와 유사하지만, 동기화된 메소드를 제공하여 멀티스레드 환경에서 사용됩니다.</li>
<li>Stack: Vector를 상속받아 구현된 클래스로, 후입선출(LIFO) 방식의 스택 구현을 제공합니다.
이 클래스들은 listIterator() 메소드를 통해 ListIterator 객체를 생성할 수 있으며, 이를 통해 리스트의 요소들을 순회하고 수정하는 등의 작업을 수행할 수 있습니다.
주요 내용은 다음과 같습니다:</li>
</ul>
<p>    양방향 이동 지원: ListIterator는 컬렉션 요소에 대한 양방향 이동을 지원합니다.
    기능 추가: Iterator 인터페이스를 상속받아 요소 대체, 추가, 인덱스 검색 등의 기능을 추가했습니다.
    List 컬렉션 클래스 사용: List 인터페이스를 구현한 List 컬렉션 클래스에서만 사용 가능합니다.
    메소드 예시: listIterator() 메소드를 사용하여 요소에 접근하고, hasNext() 및 hasPrevious() 메소드를 통해 순방향 및 역순으로 요소를 출력할 수 있습니다.</p>
<p>Map 인터페이스를 구현한 객체를 순회하는 방법은 여러 가지가 있습니다. 주요 방법은 다음과 같습니다:</p>
<p>entrySet() 사용: Map의 entrySet() 메소드는 Map 내의 모든 키-값 쌍을 Set 형태로 반환합니다. 이 Set을 순회하면서 키와 값을 얻을 수 있습니다.</p>
<pre><code><span class="hljs-keyword">for</span> (Map.<span class="hljs-keyword">Entry</span>&lt;K, V&gt; <span class="hljs-keyword">entry</span> : <span class="hljs-type">map.entrySet</span>()) {
    K key = <span class="hljs-keyword">entry</span>.getKey();
    V value = <span class="hljs-keyword">entry</span>.getValue();
    // 키와 값 사용
}
</code></pre><p>keySet() 사용: Map의 keySet() 메소드는 모든 키를 Set 형태로 반환합니다. 이 Set을 순회하면서 각 키에 해당하는 값을 Map에서 얻을 수 있습니다.</p>
<pre><code><span class="hljs-keyword">for</span> (K <span class="hljs-built_in">key</span> : <span class="hljs-built_in">map</span>.keySet()) {
    V value = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>);
    <span class="hljs-comment">// 키와 값 사용</span>
}
</code></pre><p>values() 사용: Map의 values() 메소드는 모든 값을 컬렉션 형태로 반환합니다. 이 컬렉션을 순회하면서 값을 사용할 수 있습니다.</p>
<pre><code><span class="hljs-keyword">for</span> (V <span class="hljs-keyword">value</span> : <span class="hljs-keyword">map</span>.values()) {
    // 값 사용
}
</code></pre><p>Java 8 이상의 forEach 사용: Java 8부터는 Map에 forEach 메소드가 추가되어 람다 표현식을 사용하여 간결하게 순회할 수 있습니다.</p>
<pre><code>map.forEach(<span class="hljs-function"><span class="hljs-params">(key, value)</span> -&gt;</span> {
    <span class="hljs-regexp">//</span> 키와 값 사용
});
</code></pre><h3 id="io">IO</h3>
<p>자바의 I/O(Input/Output)는 데이터의 입출력을 처리하는 기능을 말합니다1. 이는 키보드로 텍스트를 입력하고, 모니터로 입력한 텍스트를 출력하는 것과 같은 입출력의 간단한 예를 포함합니다.</p>
<p>자바에서는 java.io 패키지를 통해 다양한 I/O 관련 클래스를 제공합니다. 이 패키지는 파일과 관련된 처리를 하기 위한 File 클래스와, 데이터 입출력을 위한 다양한 입출력 스트림 클래스를 제공합니다. 스트림 클래스는 바이트(Byte) 기반의 스트림과, 문자(Character) 기반의 스트림으로 나눠집니다. 바이트 기반 스트림은 그림, 멀티미디어, 문자 등 모든 종류의 데이터를 송수신 할 수 있지만, 문자 기반 스트림은 오직 문자만 주고 받을 수 있습니다.</p>
<p>InputStream과 OutputStream은 각각 바이트 기반 입출력 스트림의 최상위 클래스입니다. 이 두 최상위 클래스를 상속받는 하위 클래스는 접미사로 InputStream 혹은 OutputStream이 붙습니다.</p>
<p>간단하게 첫 줄만 번역하면 데이터 스트림, 직렬화 및 파일 시스템을 통한 시스템 입력 및 출력 제공이라는 말을 볼 수가 있습니다. 즉, java.io 패키지 안에는 파일 입출력과 관련된 클래스들로 구성되어 있다는 의미입니다</p>
<p>자바의 I/O(Input/Output)를 사용하는 방법은 크게 세 가지 단계로 나눌 수 있습니다:</p>
<ul>
<li>스트림 생성: java.io 패키지의 클래스들을 이용해 입력 또는 출력 스트림을 생성합니다. 예를 들어, FileInputStream과 FileOutputStream 클래스는 파일로부터 바이트를 읽고 쓰는데 사용됩니다.</li>
<li>데이터 읽기/쓰기: 생성된 스트림을 통해 데이터를 읽거나 쓸 수 있습니다. read() 메소드를 이용해 데이터를 읽고, write() 메소드를 이용해 데이터를 쓸 수 있습니다.</li>
<li>스트림 닫기: 사용이 끝난 스트림은 반드시 닫아야 합니다. 이는 close() 메소드를 호출함으로써 수행할 수 있습니다.
아래는 파일에서 데이터를 읽어오는 간단한 예제입니다:</li>
</ul>
<pre><code><span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) {
        FileInputStream fis = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"input.txt"</span>);
            <span class="hljs-keyword">int</span> i;
            <span class="hljs-keyword">while</span> ((i = fis.<span class="hljs-keyword">read</span>()) != -<span class="hljs-number">1</span>) {
                System.out.<span class="hljs-keyword">print</span>((<span class="hljs-keyword">char</span>) i);
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">try</span> {
                    fis.close();
                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>이 예제에서는 FileInputStream을 이용해 &quot;input.txt&quot;라는 파일로부터 데이터를 읽어옵니다. read() 메소드는 파일의 끝에 도달하면 -1을 반환하므로, 이를 이용해 파일의 모든 데이터를 읽어올 수 있습니다. 마지막으로, finally 블록에서 close() 메소드를 호출하여 스트림을 닫습니다.</p>
<p>또한, 자바 7부터는 try-with-resources 문을 이용하여 자동으로 리소스를 닫을 수 있습니다. 이를 이용하면 finally 블록에서 수동으로 리소스를 닫는 것을 피할 수 있습니다. 아래는 try-with-resources를 이용한 예제입니다:</p>
<pre><code><span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) {
        <span class="hljs-built_in">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"input.txt"</span>)) {
            <span class="hljs-keyword">int</span> i;
            <span class="hljs-built_in">while</span> ((i = fis.<span class="hljs-built_in">read</span>()) != <span class="hljs-number">-1</span>) {
                System.out.<span class="hljs-built_in">print</span>((<span class="hljs-keyword">char</span>) i);
            }
        } <span class="hljs-built_in">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>이 예제에서는 try-with-resources 문을 이용하여 FileInputStream을 생성하고, 작업이 끝나면 자동으로 close() 메소드가 호출되어 스트림이 닫힙니다.</p>
<p>자바에서는 데이터를 입출력하기 위해 다양한 종류의 스트림을 제공합니다. 스트림은 데이터의 흐름을 다루는데 사용되며, 각 끝점의 연결 통로입니다. 스트림의 주요 종류는 다음과 같습니다:</p>
<ul>
<li>바이트 스트림 (InputStream, OutputStream): 바이트 단위로 데이터를 전송하며, 입출력 대상에 따라 여러 가지의 입출력 스트림이 있습니다. 기본 클래스로 InputStream과 OutputStream이 있으며, 입출력 대상에 따라 여러 가지 자식들을 가지고 있습니다. 예를 들어, 파일은 FileInputStream과 FileOutputStream, 메모리는 ByteArrayInputStream과 ByteArrayOutputStream 등을 사용합니다.</li>
<li>문자기반 스트림 (Reader, Writer): 문자 데이터를 읽고 출력할 때 사용합니다. 이들은 오직 문자만 주고받을 수 있게 특화되어 있습니다. 입력 문자 스트림의 종류에는 Buffer, CharArray, Filter, InputStream, Piped가 있으며, 출력 문자 스트림에는 Buffer, CharArray, Filter, OutputStream, Piped, Print, String 등이 있습니다.</li>
<li>보조 스트림: 실제 데이터를 주고받는 스트림은 아니지만, 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있습니다. 예를 들어, text 파일을 읽기 위해 FileInputStream을 사용할 때, 입력 성능을 향상시키기 위해 버퍼를 사용하는 보조스트림인 BufferedInputStream을 사용할 수 있습니다.</li>
</ul>
<p>자바의 필터 스트림은 다른 스트림과 연결되어 여러 가지 편리한 기능을 제공하는 스트림입니다.  들은 보조 스트림이라고도 불리며, 일부는 FilterInputStream과  FilterOutputStream의 하위 클래스입니다. 필터 스트림은 단독으로 데이터를 읽을 수 없으며, 입력 스트림으로부터 읽힌 데이터만 가공할 수 있습니다.</p>
<p>필터 스트림에는 여러 종류가 있습니다:</p>
<p>   - BufferedInputStream / BufferedOutputStream: 이들은 기존 FileStream을 사용했을 때보다 더 빠른 속도를 기대할 수 있습니다. 버퍼의 크기를 지정해 주지 않으면 8192 byte로 설정됩니다.
   - DataInputStream / DataOutputStream: 이들은 FilterInputStream과 FilterOutputStream을 상속받았으며, DataInput 인터페이스와 DataOutput 인터페이스를 구현하여 데이터를 읽고 쓰는 데에 있어 byte 단위가 아닌 8가지 기본 자료형의 단위를 사용할 수 있다는 장점이 있습니다.
   - PrintStream: 이 필터 스트림의 특징은, 다양한 형태의 데이터를 문자열의 형태로 출력하거나(println), 문자열의 형태로 조합하여 출력한다(printf)는 것입니다.
   - FileReader / FileWriter: 이들은 문자 기반의 파일 입출력을 수행합니다.
   - CharArrayReader / CharArrayWriter: 이들은 문자 배열을 읽고 쓰는데 사용됩니다.
   - PipedReader / PipedWriter: 이들은 스레드 간에 데이터를 전송할 때 사용됩니다.
   - StringReader / StringWriter: 이들은 문자열을 읽고 쓰는데 사용됩니다.
   - BufferedReader / BufferedWriter: 이들은 버퍼를 사용하여 입출력의 효율성을 높입니다.
   - FilterReader / FilterWriter: 이들은 필터 스트림의 기본 클래스로, 다른 필터 스트림들이 이 클래스를 상속받아 사용합니다.
<br>필터 스트림은 입출력 스트림에 연결하여 사용하면 됩니다. 이들은 파일 입출력, 문자 변환, 성능 향상, 기본 데이터 타입 입출력, 객체 입출력 등의 기능을 제공합니다.</p>
<p>PipedReader와 PipedWriter를 사용하는 간단한 자바 예제를 보여드리겠습니다. 이 예제에서는 두 개의 스레드를 생성하고, 하나의 스레드에서 다른 스레드로 문자 데이터를 전송합니다:</p>
<pre><code><span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.PipedReader;
<span class="hljs-keyword">import</span> java.io.PipedWriter;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-keyword">private</span> PipedReader pr;
    <span class="hljs-keyword">private</span> PipedWriter pw;

    MyThread(String name, PipedReader pr, PipedWriter pw) {
        <span class="hljs-keyword">super</span>(name);
        <span class="hljs-keyword">this</span>.pr = pr;
        <span class="hljs-keyword">this</span>.pw = pw;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (getName().equals(<span class="hljs-string">"Thread 1"</span>)) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; cnt &lt; <span class="hljs-number">15</span>; cnt++) {
                    pw.write(<span class="hljs-string">"Thread 1"</span> + cnt + <span class="hljs-string">"\n"</span>);
                }
                pw.close();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> item;
                <span class="hljs-keyword">while</span> ((item = pr.read()) != -<span class="hljs-number">1</span>) {
                    System.out.print((<span class="hljs-keyword">char</span>) item);
                }
                pr.close();
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipedThreads</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        PipedWriter pw = <span class="hljs-keyword">new</span> PipedWriter();
        PipedReader pr = <span class="hljs-keyword">new</span> PipedReader(pw);

        MyThread mt1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"Thread 1"</span>, pr, pw);
        MyThread mt2 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"Thread 2"</span>, pr, pw);

        mt1.start();
        Thread.sleep(<span class="hljs-number">2000</span>);
        mt2.start();
    }
}
</code></pre><p>이 코드를 실행하면 &quot;Thread 1&quot;이라는 이름의 스레드가 문자 데이터를 작성하고, &quot;Thread 2&quot;라는 이름의 스레드가 그 데이터를 읽어 출력합니다</p>
<h3 id="lambda-expression">Lambda Expression</h3>
<p>함수형 프로그래밍(Functional Programming, FP)은 계산을 수학적 함수의 평가로 취급하고, 상태 변경이나 가변 데이터를 피하는 프로그래밍 패러다임입니다. 이 방식은 코드의 가독성을 높이고, 버그를 줄이며, 프로그램의 예측 가능성을 향상시킵니다.</p>
<p>함수형 프로그래밍의 주요 원칙은 다음과 같습니다:</p>
<p>순수 함수(Pure Function): 같은 입력에 대해 항상 같은 출력을 반환하며, 프로그램의 상태를 변경하지 않는 함수를 말합니다.
일급 객체(First-class Citizen): 함수를 변수에 할당하거나, 다른 함수의 인자로 전달하고, 함수에서 함수를 반환할 수 있음을 의미합니다.
부작용(Side-Effect) 최소화: 함수형 프로그래밍은 부작용을 최소화하고, 순수 함수의 사용을 강조합니다.
자바에서는 전통적으로 객체 지향 프로그래밍 언어였지만, 자바 8부터 람다 표현식(Lambda Expressions), 스트림 API(Stream API), Optional 클래스 등 함수형 프로그래밍을 지원하는 다양한 기능을 도입했습니다1. 람다 표현식을 사용하면 코드를 더 간결하고 명확하게 작성할 수 있으며, 스트림 API를 통해 컬렉션을 함수형 스타일로 쉽게 처리할 수 있습니다.</p>
<p>람다식의 기본 구조는 다음과 같습니다.</p>
<pre><code>(매개변수, ...) -&gt; { 실행문 ... }
</code></pre><p>여기서 (매개변수, ...)는 오른쪽 중괄호 { } 블록을 실행하기 위해 필요한 값을 제공하는 역할을 합니다. 매개 변수의 이름은 개발자가 자유롭게 지정할 수 있으며 인자타입도 명시하지 않아도 됩니다. -&gt; 기호는 매개 변수를 이용해서 중괄호 { } 바디를 실행한다는 뜻으로 해석하면 됩니다.</p>
<p>간단한 람다식 사용 예제를 살펴보겠습니다:</p>
<p>람다식을 사용하지 않은 경우 </p>
<pre><code><span class="hljs-comment">// Say라는 Functional Interface를 정의합니다.</span>
@FunctionalInterface
<span class="hljs-keyword">interface</span> <span class="hljs-title">Say</span> {
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">something</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span>(<span class="hljs-params">Say line</span>) </span>{
        <span class="hljs-keyword">int</span> number = line.something(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Number is "</span> + number);
    }
}

<span class="hljs-comment">// 람다식을 사용하지 않고 Say 인터페이스를 구현합니다.</span>
Person person = <span class="hljs-keyword">new</span> Person();
person.hi(<span class="hljs-keyword">new</span> Say() {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">something</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>) </span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"My Name is Coding-Factory"</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Nice to meet you"</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Parameter number is "</span> + a + <span class="hljs-string">", "</span> + b);
        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;
    }
});
</code></pre><p>람다식을 사용한 경우</p>
<pre><code><span class="hljs-comment">// 람다식을 사용하여 Say 인터페이스를 구현합니다.</span>
Person person = <span class="hljs-keyword">new</span> Person();
person.hi((a, b) -&gt; {
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"This is Coding-Factory!"</span>);
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Thank you, Lambda"</span>);
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Parameter number is "</span> + a + <span class="hljs-string">", "</span> + b);
    <span class="hljs-built_in">return</span> <span class="hljs-number">7</span>;
});
</code></pre><p>람다식의 장단점:</p>
<p>장점:
코드를 간결하게 만들 수 있습니다.
가독성이 향상되며, 개발자의 의도가 명확하게 드러납니다.
함수를 만들지 않고 한 번에 처리할 수 있어 코딩 시간이 줄어듭니다.
병렬 프로그래밍에 용이합니다.
단점:
람다를 사용하여 만든 무명 함수는 재사용이 불가능합니다.
디버깅이 다소 까다롭습니다.
람다를 남발하면 코드가 지저분해질 수 있습니다.
재귀로 만들 경우에는 다소 부적합할 수 있습니다.</p>
<h3 id="functional-interface">Functional Interface</h3>
<p>자바에서 함수형 인터페이스(Functional Interface)는 추상 메서드가 딱 하나만 존재하는 인터페이스를 말합니다. 이는 함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로, 인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할을 합니다. 람다식은 이러한 함수형 인터페이스를 기반으로만 작성이 될 수 있습니다.</p>
<p>함수형 인터페이스는 자바 언어의 단점을 보완하기 위해 도입되었습니다. 자바는 기본적으로 함수를 일급 객체로 사용할 수 없는데, 이를 보완하기 위해 함수형 인터페이스가 도입되었습니다. 덕분에 자바는 전보다 간결한 표현이 가능해졌고, 가독성이 높아졌습니다.</p>
<p>함수형 프로그래밍을 사용하는 이유는 여러 가지가 있습니다:</p>
<ul>
<li><p>높은 수준의 추상화: 함수형 프로그래밍은 높은 수준의 추상화를 제공합니다. 이를 통해 코드의 복잡성을 줄이고 가독성을 높일 수 있습니다.</p>
</li>
<li><p>코드 재사용성: 함수형 프로그래밍에서는 함수를 일급 객체로 취급하기 때문에, 함수 단위의 코드 재사용이 수월합니다.</p>
</li>
<li><p>예측 가능성: 함수형 프로그래밍은 불변성을 지향하며, 순수 함수를 사용합니다. 이로 인해 프로그램의 동작을 예측하기 쉬워집니다.</p>
</li>
<li><p>병렬 처리와 동시성: 함수형 프로그래밍은 부수 효과(Side Effect)가 없기 때문에, 멀티코어나 병렬 컴퓨팅 환경에서의 프로그래밍이 용이합니다.</p>
</li>
<li><p>명확성: 함수형 프로그래밍에서 함수가 하는 일은 명확하게 정의되기 때문에 코드를 읽을 때 이해하기 쉽습니다.</p>
</li>
<li><p>디버깅과 테스트 용이성: 함수형 프로그래밍은 순수 함수를 사용하므로, 디버깅이 쉽고 단위 테스트를 더 쉽게 실행할 수 있습니다.</p>
</li>
<li><p>개발자의 생산성 향상: 함수형 프로그래밍은 코드의 간결성과 모듈성을 높여 개발자의 생산성을 향상시킵니다.</p>
<p>하지만 함수형 프로그래밍은 기존의 명령형 프로그래밍에 익숙한 개발자에게는 초기 학습 곡선이 있을 수 있으며, 특정 문제를 해결하기 위한 직관적인 접근이 어려울 수 있습니다. 또한, 일부 상황에서는 함수형 프로그래밍이 성능 측면에서 비효율적일 수 있습니다.</p>
</li>
</ul>
<p>함수형 인터페이스는 다음과 같은 형태를 가집니다:</p>
<pre><code class="lang-java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-class"><span class="hljs-keyword">interface</span>
 <span class="hljs-title">InterfaceName</span> </span>{     ReturnType methodName(<span class="hljs-built_in">Type</span> parameter); }
</code></pre>
<p>여기서 @FunctionalInterface는 이 인터페이스가 함수형 인터페이스임을 나타내는 어노테이션입니다. InterfaceName은 인터페이스의 이름, methodName은 메소드의 이름, Type은 매개변수의 타입, ReturnType은 메소드의 반환 타입을 나타냅니다.</p>
<p>자바에서 함수형 인터페이스를 사용하는 간단한 예제는 다음과 같습니다:</p>
<pre><code class="lang-java">@FunctionalInterface
<span class="hljs-keyword">interface</span> <span class="hljs-title">Compare</span> {
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex62</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exec</span>(<span class="hljs-params">Compare com</span>) </span>{
        <span class="hljs-keyword">int</span> k = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">20</span>;
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span> = com.compareTo(k, m);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">value</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        exec((i, j) -&gt; {
            <span class="hljs-keyword">return</span> i + j;
        });
    }
}
</code></pre>
<p>이 예제에서는 Compare라는 함수형 인터페이스를 선언하고, compareTo라는 메소드를 정의합니다. 그리고 exec라는 메소드에서 Compare 인터페이스의 compareTo 메소드를 호출합니다. 마지막으로 main 메소드에서 exec 메소드를 호출하면서 람다식 (i, j) -&gt; { return i + j; }을 인자로 전달합니다.</p>
<h4 id="-">자바 내장 라이브러리에서 제공하는 함수형 인터페이스</h4>
<table>
<thead>
<tr>
<th>인터페이스명</th>
<th>매개 값</th>
<th>리턴 값</th>
<th>내부 메소드</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consumer</td>
<td>O<br> (타입: T)</td>
<td>X 값을 소비하고<br> 리턴하지 않음</td>
<td>accept()</td>
</tr>
<tr>
<td>Supplier</td>
<td>X</td>
<td>O<br> (타입: T) Consumer와 반대로 값을 만들기만하고 소비하지 않음</td>
<td>get()</td>
</tr>
<tr>
<td>Function</td>
<td>O<br> (타입: T)</td>
<td>O<br> (타입: A) 주로 매개 값을<br> 리턴 값으로 매핑하는데 사용됨 보통 매개 값과<br> 리턴 값의 타입이 다름</td>
<td>apply()</td>
</tr>
<tr>
<td>Operator</td>
<td>O<br> (타입: T)</td>
<td>O<br> (타입: T) 주로 매개 값을<br> 이용한 연산 후 결과를 리턴함 보통 매개 값과<br> 리턴 값의 타입이 같음</td>
<td>apply()</td>
</tr>
<tr>
<td>Predicate</td>
<td>O<br> (타입: T)</td>
<td>O<br> (타입: boolean) 매개 값을 이용한<br> 조건식을 통해 true 혹은 false를 반환</td>
<td>test()</td>
</tr>
</tbody>
</table>
<h3 id="stream-api">Stream API</h3>
<h4 id="stream">Stream</h4>
<ol>
<li><p>생성하기: 스트림 객체를 생성하는 단계입니다. 스트림은 재사용이 불가능하므로, 닫히면 다시 생성해주어야 합니다. 이는 Collection 인터페이스에 정의된 stream() 메소드를 호출함으로써 수행할 수 있습니다.</p>
</li>
<li><p>중간처리: 원본의 데이터를 별도의 데이터로 가공하기 위한 중간 연산입니다. 연산 결과를 스트림으로 다시 반환하기 때문에 연속해서 중간 연산을 이어갈 수 있습니다. 예를 들어, 필터링(filter, distinct), 정렬(sorted), 매핑(mapXxx), 반복(peek) 등의 메소드가 있습니다.</p>
</li>
<li><p>최종처리: 가공된 데이터로부터 원하는 결과를 만들기 위한 최종 연산입니다. 예를 들어, 반복(forEach), 카운팅(count), 평균(average), 리듀스(reduce) 등의 메소드가 있습니다.</p>
</li>
</ol>
<h4 id="stream-">Stream 생성</h4>
<ul>
<li><a href="https://codechacha.com/ko/stream-creation/#1-streamof%EB%A1%9C-stream-%EC%83%9D%EC%84%B1">1. Stream.of()로 Stream 생성</a></li>
<li><a href="https://codechacha.com/ko/stream-creation/#2-streamempty%EB%A1%9C-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-stream-%EC%83%9D%EC%84%B1">2. Stream.empty()로 비어있는 Stream 생성</a></li>
<li><a href="https://codechacha.com/ko/stream-creation/#3-liststream%EC%9C%BC%EB%A1%9C-stream-%EC%83%9D%EC%84%B1">3. List.stream()으로 Stream 생성</a></li>
<li><a href="https://codechacha.com/ko/stream-creation/#4-arraysstream%EC%9C%BC%EB%A1%9C-stream-%EC%83%9D%EC%84%B1">4. Arrays.stream()으로 Stream 생성</a></li>
<li><a href="https://codechacha.com/ko/stream-creation/#5-streamgenerate%EB%A1%9C-stream-%EC%83%9D%EC%84%B1">5. Stream.generate()로 Stream 생성</a></li>
<li><a href="https://codechacha.com/ko/stream-creation/#6-streamiterate%EB%A1%9C-stream-%EC%83%9D%EC%84%B1">6. Stream.iterate()로 Stream 생성</a></li>
</ul>
<h5 id="1-stream-of-stream-">1. Stream.of()로 Stream 생성</h5>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"item1"</span>, <span class="hljs-string">"item2"</span>, <span class="hljs-string">"item3"</span>, <span class="hljs-string">"item4"</span>);

stream.forEach(s -&gt; System.out.<span class="hljs-built_in">println</span>(s));
</code></pre>
<h5 id="2-stream-empty-stream-">2.  Stream.empty()로 비어있는 Stream 생성</h5>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.empty();

stream.forEach(s -&gt; System.out.<span class="hljs-built_in">println</span>(s));
</code></pre>
<h5 id="3-list-stream-stream-">3.  List.stream()으로 Stream 생성</h5>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> =
        Arrays.asList(<span class="hljs-string">"a1"</span>, <span class="hljs-string">"a2"</span>, <span class="hljs-string">"b1"</span>, <span class="hljs-string">"b2"</span>, <span class="hljs-string">"c2"</span>, <span class="hljs-string">"c1"</span>);
Stream&lt;<span class="hljs-built_in">String</span>&gt; stream = <span class="hljs-built_in">list</span>.stream();

stream.forEach(System.out<span class="hljs-type">::println</span>);
</code></pre>
<h5 id="4-arrays-stream-stream-">4.  Arrays.stream()으로 Stream 생성</h5>
<pre><code class="lang-java"><span class="hljs-keyword">String</span>[] <span class="hljs-keyword">array</span> = {<span class="hljs-string">"a1"</span>, <span class="hljs-string">"a2"</span>, <span class="hljs-string">"b1"</span>, <span class="hljs-string">"b2"</span>, <span class="hljs-string">"c2"</span>, <span class="hljs-string">"c1"</span>};
<span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = Arrays.stream(<span class="hljs-keyword">array</span>);

stream.forEach(System.out::<span class="hljs-built_in">println</span>);
</code></pre>
<h5 id="5-stream-generate-stream-">5. Stream.generate()로 Stream 생성</h5>
<pre><code class="lang-java">Stream&lt;String&gt; stream = Stream.generate<span class="hljs-function"><span class="hljs-params">(() -&gt; <span class="hljs-string">"item"</span>)</span>.<span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>;

<span class="hljs-title">stream</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(System.out::println)</span>;</span>
</code></pre>
<h5 id="6-stream-iterate-stream-">6. Stream.iterate()로 Stream 생성</h5>
<pre><code class="lang-java">Stream<span class="hljs-variable">&lt;Integer&gt;</span> stream = Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).<span class="hljs-keyword">limit</span>(<span class="hljs-number">5</span>);

stream.<span class="hljs-keyword">for</span>Each(System.<span class="hljs-keyword">out</span>::println);
</code></pre>
<h5 id="7-stream-builder-stream-">7. Stream.builder()로 Stream 생성</h5>
<pre><code class="lang-java">Stream&lt;<span class="hljs-keyword">String</span>&gt; builderStream = 
Stream.&lt;<span class="hljs-keyword">String</span>&gt;builder()
    .<span class="hljs-built_in">add</span>(<span class="hljs-string">"item1"</span>).<span class="hljs-built_in">add</span>(<span class="hljs-string">"item2"</span>).<span class="hljs-built_in">add</span>(<span class="hljs-string">"item3"</span>)
    .build();
</code></pre>
<h5 id="8-xxxstream-range-stream-">8. XxxStream.range()로 Stream 생성</h5>
<pre><code class="lang-java">IntStream intStream = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// [1, 2, 3, 4]</span>
LongStream longStream = LongStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>

Stream&lt;Integer&gt; boxedIntStream = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).boxed();
</code></pre>
<h5 id="9-random-stream-">9. Random으로 Stream 생성</h5>
<pre><code class="lang-java"><span class="hljs-type">DoubleStream</span> doubles = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().<span class="hljs-title">doubles</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 난수 3개 생성</span></span>
</code></pre>
<h5 id="10-string-stream-">10. String으로 Stream 생성</h5>
<pre><code class="lang-java">IntStream charsStream = 
  <span class="hljs-string">"Stream"</span>.chars(); <span class="hljs-comment">// [83, 116, 114, 101, 97, 109]</span>

<span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stringStream = 
  Pattern.compile(<span class="hljs-string">", "</span>).splitAsStream(<span class="hljs-string">"Eric, Elena, Java"</span>);
  <span class="hljs-comment">// [Eric, Elena, Java]</span>
</code></pre>
<h5 id="11-nio-files-stream-">11. NIO 의 <code>Files</code>로 Stream 생성</h5>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; lineStream = 
  Files.lines(Paths.<span class="hljs-built_in">get</span>(<span class="hljs-string">"file.txt"</span>), 
              Charset.forName(<span class="hljs-string">"UTF-8"</span>));
</code></pre>
<h4 id="-">중간처리 - 필터링</h4>
<p>distinct() : 스트림에서 중복되는 요소들을 모두 제거해주고 새로운 스트림을 반환</p>
<pre><code class="lang-java"><span class="hljs-symbol">List</span>&lt;<span class="hljs-keyword">String&gt; </span>msgs =
        Arrays.asList(<span class="hljs-string">"item1"</span>, <span class="hljs-string">"item2"</span>, <span class="hljs-string">"item2"</span>, <span class="hljs-string">"item3"</span>, <span class="hljs-string">"item1"</span>)<span class="hljs-comment">;</span>

<span class="hljs-keyword">Stream&lt;String&gt; </span><span class="hljs-keyword">stream1 </span>= msgs.<span class="hljs-keyword">stream();
</span><span class="hljs-keyword">Stream&lt;String&gt; </span><span class="hljs-keyword">stream2 </span>= <span class="hljs-keyword">stream1.distinct();
</span><span class="hljs-keyword">stream2.forEach(System.out::println);</span>
</code></pre>
<p>filter() : 인자로 함수를 받으며, 어떤 조건으로 Stream의 요소들을 필터링</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> =
        Arrays.asList(<span class="hljs-string">"a1"</span>, <span class="hljs-string">"a2"</span>, <span class="hljs-string">"b1"</span>, <span class="hljs-string">"b2"</span>, <span class="hljs-string">"c2"</span>, <span class="hljs-string">"c1"</span>, <span class="hljs-string">"c3"</span>);
Stream&lt;<span class="hljs-built_in">String</span>&gt; stream = <span class="hljs-built_in">list</span>.stream();
Stream&lt;<span class="hljs-built_in">String</span>&gt; filtered = stream.filter(s -&gt; s.startsWith(<span class="hljs-string">"c"</span>));
filtered.forEach(System.out<span class="hljs-type">::println</span>);
</code></pre>
<h4 id="-">중간처리 - 정렬</h4>
<p><code>sorted()</code>에서 요소들을 어떻게 정렬해야하는지에 대한 내용은 Comparable 또는 Comparator에 구현</p>
<pre><code class="lang-java"><span class="hljs-keyword">List</span>&lt;String&gt; langs =
        Arrays.asLis(<span class="hljs-string">"bb11"</span>, <span class="hljs-string">"dd222"</span>, <span class="hljs-string">"aa3"</span>, <span class="hljs-string">"cc44"</span>);
<span class="hljs-comment">//sorted:</span>
langs.stream().sorted()
        .<span class="hljs-keyword">forEach</span>(System.out::println);

<span class="hljs-comment">//reversed:</span>
langs.stream().sorted(Comparator.reverseOrder())
        .<span class="hljs-keyword">forEach</span>(System.out::println);

<span class="hljs-comment">//length sort</span>
langs.stream().sorted(Comparator.comparing(String::length))
        .<span class="hljs-keyword">forEach</span>(System.out::println);
langs.stream().sorted(Comparator.comparing(String::length).reversed())
        .<span class="hljs-keyword">forEach</span>(System.out::println);

<span class="hljs-keyword">final</span> Comparator&lt;String&gt; comp = (p1, p2) -&gt; Integer.compare( p1.length(), p2.length());
langs.stream().sorted(comp).<span class="hljs-keyword">forEach</span>(System.out::println);
langs.stream().sorted(comp.reversed()).<span class="hljs-keyword">forEach</span>(System.out::println);
</code></pre>
<h4 id="-">중간처리 - 매핑</h4>
<p><code>map()</code>: 인자로 함수를 받으며, Stream의 요소를 다른 형태로 변경</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> =
        Arrays.asList(<span class="hljs-string">"item1"</span>, <span class="hljs-string">"item2"</span>, <span class="hljs-string">"item3"</span>, <span class="hljs-string">"item4"</span>);
Stream&lt;<span class="hljs-built_in">String</span>&gt; stream = <span class="hljs-built_in">list</span>.stream();
stream.<span class="hljs-built_in">map</span>(s -&gt; s.toUpperCase()).forEach(System.out<span class="hljs-type">::println</span>);
<span class="hljs-comment">//</span>
<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; list2 =
        Arrays.asList(<span class="hljs-string">"item1"</span>, <span class="hljs-string">"item2"</span>, <span class="hljs-string">"item3"</span>, <span class="hljs-string">"item4"</span>);
Stream&lt;<span class="hljs-built_in">String</span>&gt; stream2 = list2.stream();
stream2.<span class="hljs-built_in">map</span>(<span class="hljs-built_in">String</span><span class="hljs-type">::toUpperCase</span>).forEach(System.out<span class="hljs-type">::println</span>);
</code></pre>
<p><code>flatMap()</code>: 평탄화라고 부르기도 하며, 복잡한 자료 구조에 저장된 요소들을 단순한 자료구조로 변환</p>
<pre><code class="lang-java"><span class="hljs-keyword">String[][] </span>arrays = new <span class="hljs-keyword">String[][]{ </span>{<span class="hljs-string">"a1"</span>, <span class="hljs-string">"a2"</span>}, {<span class="hljs-string">"b1"</span>, <span class="hljs-string">"b2"</span>}, {<span class="hljs-string">"c1"</span>, <span class="hljs-string">"c2"</span>, <span class="hljs-string">"c3"</span>} }<span class="hljs-comment">;</span>
<span class="hljs-keyword">Stream&lt;String[]&gt; </span><span class="hljs-keyword">stream </span>= Arrays.<span class="hljs-keyword">stream(arrays);
</span><span class="hljs-keyword">Stream&lt;String&gt; </span><span class="hljs-keyword">stream </span>= <span class="hljs-keyword">stream.flatMap(s </span>-&gt; Arrays.<span class="hljs-keyword">stream(s));
</span><span class="hljs-keyword">stream.forEach(System.out::println);</span>
</code></pre>
<h4 id="-">중간처리 - 반복</h4>
<p>peek() : 중간단계에서 반복이 필요할때 작성</p>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>)
  .filter(e -&gt; e.length() &gt; <span class="hljs-number">3</span>)
  .<span class="hljs-built_in">peek</span>(e -&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Filtered value: "</span> + e))
  .<span class="hljs-built_in">map</span>(<span class="hljs-keyword">String</span>::toUpperCase)
  .<span class="hljs-built_in">peek</span>(e -&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Mapped value: "</span> + e))
  .collect(Collectors.toList());
</code></pre>
<h4 id="-">중간처리 - 병합</h4>
<p>concat() : 두개의 스트림을 하나로 통합</p>
<pre><code class="lang-java"><span class="hljs-symbol">List</span>&lt;<span class="hljs-keyword">String&gt; </span>numbers = Arrays.asList(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>)<span class="hljs-comment">;</span>
<span class="hljs-symbol">List</span>&lt;<span class="hljs-keyword">String&gt; </span>chars = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>)<span class="hljs-comment">;</span>
<span class="hljs-keyword">Stream&lt;String&gt; </span><span class="hljs-keyword">stream1 </span>= numbers.<span class="hljs-keyword">stream();
</span><span class="hljs-keyword">Stream&lt;String&gt; </span><span class="hljs-keyword">stream2 </span>= chars.<span class="hljs-keyword">stream();
</span><span class="hljs-keyword">Stream&lt;String&gt; </span><span class="hljs-keyword">stream3 </span>= <span class="hljs-keyword">Stream.concat(stream1, </span><span class="hljs-keyword">stream2);
</span><span class="hljs-keyword">stream3.forEach(System.out::println);</span>
</code></pre>
<h4 id="-">최종처리</h4>
<p>반복(forEach) : 매개타입인 Consumer는 함수형 인터페이스</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> = Arrays.asList(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
<span class="hljs-built_in">list</span>.stream()
            .forEach(System.out<span class="hljs-type">::println</span>);
</code></pre>
<p>매칭(allMatch(), anyMatch(), noneMatch())</p>
<pre><code class="lang-java"><span class="hljs-built_in">int</span>[] intArr = { <span class="hljs-number">2</span>, <span class="hljs-number">4</span> ,<span class="hljs-number">6</span> };

boolean <span class="hljs-literal">result</span> = <span class="hljs-type">Arrays</span>.stream(intArr)
            .allMatch(a -&gt; a%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>);
<span class="hljs-type">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"모두 2의 배수인가? "</span> + <span class="hljs-literal">result</span>);

<span class="hljs-literal">result</span> = <span class="hljs-type">Arrays</span>.stream(intArr)
            .anyMatch(a -&gt; a%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>);
<span class="hljs-type">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"하나라도 3의 배수가 있는가? "</span> + <span class="hljs-literal">result</span>);

<span class="hljs-literal">result</span> = <span class="hljs-type">Arrays</span>.stream(intArr)
            .noneMatch(a -&gt; a%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>);
<span class="hljs-type">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"3의 배수가 없는가?  "</span> + <span class="hljs-literal">result</span>);
</code></pre>
<p>집계 (sum)</p>
<pre><code class="lang-java">IntStream stream = IntStream.<span class="hljs-keyword">range</span>(1, 101);
        stream.<span class="hljs-keyword">forEach</span>(a -&gt; <span class="hljs-keyword">sum</span> += a);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"총합: "</span> + <span class="hljs-keyword">sum</span>);
</code></pre>
<p>집계(max, min)</p>
<pre><code class="lang-java"><span class="hljs-selector-tag">IntStream</span><span class="hljs-selector-class">.range</span>(10, 21)
        <span class="hljs-selector-class">.min</span>()<span class="hljs-selector-class">.ifPresent</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println)</span>;

<span class="hljs-selector-tag">IntStream</span><span class="hljs-selector-class">.range</span>(10, 21)
        <span class="hljs-selector-class">.max</span>()<span class="hljs-selector-class">.ifPresent</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println)</span>;
</code></pre>
<p>집계 - 카운팅(count)</p>
<pre><code class="lang-java">List&lt;<span class="hljs-keyword">String</span>&gt; langs =Arrays.asList(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>);

<span class="hljs-keyword">long</span> cnt = langs.stream()
            .<span class="hljs-built_in">map</span>(e-&gt;Integer.<span class="hljs-built_in">parseInt</span>(e))
            .count();
System.out.<span class="hljs-built_in">println</span>(cnt);

IntSummaryStatistics summary = langs.stream()
            .mapToInt(Integer::<span class="hljs-built_in">parseInt</span>).summaryStatistics();
System.out.<span class="hljs-built_in">println</span>(summary.getCount());
</code></pre>
<p>집계 - 평균(average)</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; langs = Arrays.asList(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>);

IntStream stream1 = langs.stream()
            .mapToInt(<span class="hljs-built_in">Integer</span><span class="hljs-type">::parseInt</span>);
System.out.println(stream1.<span class="hljs-keyword">average</span>().getAsDouble());

IntSummaryStatistics summary = langs.stream()
            .mapToInt(<span class="hljs-built_in">Integer</span><span class="hljs-type">::parseInt</span>).summaryStatistics();
System.out.println(summary.getAverage());
</code></pre>
<p>리듀스(reduce)</p>
<pre><code class="lang-java">List&lt;String&gt; langs = Arrays.asList(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>);

Optional&lt;String&gt; op = langs.stream()
        reduce<span class="hljs-function"><span class="hljs-params">((a,b)-&gt;String.valueOf(
                        Integer.parseInt(a)+Integer.parseInt(b)))</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(op.get())</span>;

<span class="hljs-title">OptionalInt</span> <span class="hljs-title">op2</span> = <span class="hljs-title">langs</span>.<span class="hljs-title">stream</span><span class="hljs-params">()</span>
        .<span class="hljs-title">mapToInt</span><span class="hljs-params">(Integer::parseInt)</span>
        .<span class="hljs-title">reduce</span><span class="hljs-params">((a,b)-&gt;a+b)</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(op2.getAsInt())</span>;

<span class="hljs-title">Stream</span>&lt;<span class="hljs-title">Integer</span>&gt; <span class="hljs-title">stream</span> = <span class="hljs-title">langs</span>.<span class="hljs-title">stream</span><span class="hljs-params">()</span>.<span class="hljs-title">map</span><span class="hljs-params">(Integer::parseInt)</span>;
<span class="hljs-title">Optional</span>&lt;<span class="hljs-title">Integer</span>&gt; <span class="hljs-title">op3</span> = <span class="hljs-title">stream</span>.<span class="hljs-title">reduce</span><span class="hljs-params">((a,b)-&gt;a+b)</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(op3.get())</span>;</span>
</code></pre>
<p>수집(collect)</p>
<p>스트림의 요소들을 수집하는 데 사용됩니다. 이 메소드는 주로 스트림의 요소들을 리스트, 세트, 맵 등의 컬렉션으로 변환하거나, 문자열로 결합하거나, 특정 조건에 따라 가장 큰 요소를 찾거나, 요소들의 평균 값을 계산하는 등의 작업에 사용됩니다</p>
<ol>
<li><strong>스트림의 요소들을 List로 수집하기</strong>:</li>
</ol>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
List&lt;<span class="hljs-keyword">String</span>&gt; list = stream.collect(Collectors.toList());
System.out.<span class="hljs-built_in">println</span>(list);
</code></pre>
<ol>
<li><strong>스트림의 요소들을 Set로 수집하기</strong>:</li>
</ol>
<pre><code class="lang-java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
<span class="hljs-keyword">Set</span>&lt;String&gt; <span class="hljs-keyword">set</span> <span class="hljs-comment">= stream.collect(Collectors.toSet())</span>;
<span class="hljs-keyword">System</span>.out.println(<span class="hljs-keyword">set</span>);
</code></pre>
<ol>
<li><strong>스트림의 요소들을 Map로 수집하기</strong>:</li>
</ol>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
Map&lt;<span class="hljs-keyword">String</span>, Integer&gt; <span class="hljs-built_in">map</span> = stream.collect(
                            Collectors.toMap(s -&gt; s, <span class="hljs-keyword">String</span>::length));
System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">map</span>);  <span class="hljs-comment">// 출력: {apple=5, banana=6, cherry=6, date=4}</span>
</code></pre>
<ol>
<li><strong>스트림의 요소들을 문자열로 결합하기:</strong></li>
</ol>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
<span class="hljs-keyword">String</span> joined = stream.collect(Collectors.joining(<span class="hljs-string">", "</span>));
System.out.<span class="hljs-built_in">println</span>(joined);
</code></pre>
<ol>
<li><strong>스트림의 요소들을 정렬하여 가장 큰 객체, 작은 객체 찾기</strong>:</li>
</ol>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
Optional&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">max</span> = stream.collect(Collectors.maxBy(Comparator.naturalOrder()));
<span class="hljs-comment">// Optional&lt;String&gt; min = stream.collect(Collectors.maxBy(Comparator.reverseOrder()));</span>
stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
Optional&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">min</span> = stream.collect(Collectors.minBy(Comparator.naturalOrder()));
<span class="hljs-comment">// Optional&lt;String&gt; max = stream.collect(Collectors.minBy(Comparator.reverseOrder()));</span>
System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">String</span>.format(<span class="hljs-string">"min:%s, max:%s"</span>, <span class="hljs-built_in">min</span>.<span class="hljs-built_in">get</span>() ,<span class="hljs-built_in">max</span>.<span class="hljs-built_in">get</span>()));
</code></pre>
<ol>
<li><strong>스트림의 요소들의 평균 값 계산하기</strong>:</li>
</ol>
<pre><code class="lang-java"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-keyword">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
Double average = stream.collect(Collectors.averagingInt(<span class="hljs-keyword">String</span>::length));
System.out.<span class="hljs-built_in">println</span>(average);
</code></pre>
<p><strong>7. 그룹화하기:</strong></p>
<pre><code class="lang-java">Stream&lt;<span class="hljs-built_in">String</span>&gt; stream = Stream.of(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
 <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; lengGroup = stream.collect(Collectors.groupingBy(<span class="hljs-built_in">String</span><span class="hljs-type">::length</span>));
System.out.println(lengGroup);
</code></pre>
<p>병렬화</p>
<p>parallelStream : 컬렉션(List, Set)으로부터 병렬 스트림을 바로 리턴</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> = Arrays.asList(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
<span class="hljs-built_in">list</span>.parallelStream()
            .forEach(System.out<span class="hljs-type">::println</span>);
</code></pre>
<p>parallel() : 기존 스트림을 병렬 처리 스트림으로 변환</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> = Arrays.asList(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"cherry"</span>, <span class="hljs-string">"date"</span>);
<span class="hljs-built_in">list</span>.stream().parallel()
            .forEach(System.out<span class="hljs-type">::println</span>);
</code></pre>
<p>#### </p>
<h4 id="-">기타</h4>
<p><code>Optional&lt;Type&gt;</code>: 단순히 어떤 객체를 wrapping하는 객체</p>
<pre><code class="lang-java"><span class="hljs-keyword">String</span> <span class="hljs-keyword">string</span> = <span class="hljs-string">"a string in optional"</span>;
Optional&lt;<span class="hljs-keyword">String</span>&gt; opString = Optional.of(<span class="hljs-keyword">string</span>);
System.out.<span class="hljs-built_in">println</span>(opString.<span class="hljs-built_in">get</span>());

<span class="hljs-comment">// Optional.of(null) 불가 </span>
<span class="hljs-keyword">String</span> nullString = null;
Optional&lt;<span class="hljs-keyword">String</span>&gt; nullOpString = Optional.ofNullable(nullString);
Optional&lt;<span class="hljs-keyword">String</span>&gt; emptyOptional = Optional.empty();
<span class="hljs-built_in">try</span> {
    System.out.<span class="hljs-built_in">println</span>(nullOpString.<span class="hljs-built_in">get</span>());
} <span class="hljs-built_in">catch</span> (NoSuchElementException e) {
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"No such element"</span>);
}
System.out.<span class="hljs-built_in">println</span>(emptyOptional.isPresent()!=true)
</code></pre>
<style>
</style>

<p>## </p>
<h2 id="3-">3일차</h2>
<p>### </p>
<h3 id="thread">Thread</h3>
<p>프로세스(Process): 프로세스는 실행 중인 프로그램을 의미하며, 운영체제로부터 자원을 할당받은 독립적인 작업 단위입니다. 각 프로세스는 독립된 메모리 영역(Code, Data, Stack,
Heap)을 가지고 있어, 다른 프로세스와 자원을 공유하지 않습니다.</p>
<p>스레드(Thread): 스레드는 프로세스 내에서 실행되는 실행 흐름의 단위로, 프로세스의 자원을 공유합니다. 스레드는 프로세스 내에서 코드, 데이터, 힙 영역을 공유하면서 실행되지만, 각 스레드마다 별도의 스택을 가집니다.</p>
<p>간단히 말해, 프로세스는 실행 중인 프로그램 자체이고, 스레드는 그 프로그램 내에서 개별적으로 실행되는 작업의 흐름입니다. 멀티스레딩을 사용하면 하나의 프로세스 내에서 여러 작업을 동시에 처리할 수 있어, 자원을 보다 효율적으로 사용할 수 있습니다.</p>
<p>스레드의 역사는 1965년 버클리 시분할 시스템에서 &#39;프로세스’라는 이름으로 처음 사용되었습니다. 이후, 1970년대에 멀틱스(Multics)에서 맥스 스미스(Max Smith)에 의해 최초로 구현되었고, IBM의 PL/I 프로그래밍 언어에서도 ‘TASK’ 명령을 통해 스레드를 생성할 수 있었습니다. 유닉스의 등장과 함께 프로세스 개념이 확장되었고, 이후 사용자들은 메모리를 공유할 수 있는 ‘라이트웨이트(lightweight)’ 스레드를 그리워하게 되었으며, 이것이 스레드 발명으로 이어졌습니다.</p>
<p>스레드는 프로그램 내에서 실행되는 흐름의 단위로, 일반적으로 한 프로그램은 하나의 스레드를 가지지만, 멀티스레드 환경에서는 여러 스레드를 동시에 실행할 수 있습니다.</p>
<p>스레드는 현대 운영체제의 핵심 기술로, 프로세스 내에서 독립적인 실행 흐름을 가지며, 프로세스의 자원과 메모리를 공유합니다. 스레드 구현에는 사용자 수준 스레드와 커널 수준 스레드 두 가지 방식이 있으며, 이를 통해 멀티태스킹 환경에서 프로그램의 응답성이 향상되고, 시스템의 자원을 보다 효율적으로 사용할 수 있습니다.</p>
<p>쓰레드란 프로그램(프로세스) 실행의 단위이며 하나의 프로세스는 여러개의 쓰레드로 구성이 가능하다.</p>
<p>하나의 프로세스를 구성하는 쓰레드들은 프로세스에 할당된 메모리, 자원 등을 공유한다.</p>
<p>프로세스와 같이 실행, 준비, 대기 등의 실행 상태를 가지며 실행 상태가 변할때마다 쓰레드 문맥교환(context switching)을 수행한다.</p>
<p>각 쓰레드별로 자신만의 스택과 레지스터를 가진다.</p>
<p><img src="https://goodgid.github.io/assets/img/os/what_is_thread_1.png" alt=""></p>
<p>PC 레지스터(Program Counter)는 현재 실행 중인 스레드의 JVM(Java Virtual Machine) 명령어 주소를 가리키는 데 사용됩니다. 이 레지스터는 JVM이 실행하는 각 스레드마다 별도로 존재하며, 현재 실행 중인 명령어의 위치를 추적하는 데 중요한 역할을 합니다</p>
<p><img/></p>
<p>자바 스레드의 라이프사이클은 다음과 같은 상태로 구성됩니다:</p>
<ul>
<li><p>Runnable (준비상태): 스레드 객체가 생성되고 실행될 준비가 된 상태입니다start() 메소드 호출로 이 상태에 진입합니다.</p>
</li>
<li><p>Running (실행상태): 스레드가 CPU 스케줄러에 의해 선택되어 실행되는 상태입니다.</p>
</li>
<li><p>Blocked (지연 상태): 스레드가 실행 중 일시적으로 작업을 멈추고 대기하는 상태입니다. 이는 동기화 블록에 의해 발생하거나, I/O 작업을 기다리는 경우에 발생할 수 있습니다.</p>
</li>
<li><p>Dead (종료상태): 스레드의 run() 메소드가 완료되어 더 이상 실행할 코드가 없거나, stop() 메소드가 호출되어 스레드가 종료된 상태입니다.</p>
</li>
</ul>
<p>스레드의 상태는 Thread.State 열거형을 통해 확인할 수 있으며, 스레드의 상태를 관리하는 것은 자바 멀티스레드 프로그래밍에서 중요한 부분입니다. 각 상태는 스레드의 작업 수행 능력과 관련이 있으며, 스레드 스케줄링과 동기화에 영향을 미칩니다.</p>
<p><img/></p>
<p>자바에서 스레드를 생성하는 방법은 크게 두 가지가 있습니다:</p>
<p>Thread 클래스 상속: Thread 클래스를 상속받아 run() 메소드를 오버라이드하는 방법입니다. 예를 들어:</p>
<pre><code>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-meta">@Override</span>
    public void run() {
        <span class="hljs-comment">// 스레드가 실행할 코드</span>
    }
}
</code></pre><p>그리고 start() 메소드를 호출하여 스레드를 실행합니다:</p>
<pre><code><span class="hljs-type">MyThread</span> t = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">MyThread</span>();
<span class="hljs-title">t</span>.<span class="hljs-title">start</span>();</span>
</code></pre><p>Runnable 인터페이스 구현: Runnable 인터페이스를 구현하고, run() 메소드를 오버라이드하여 스레드를 생성하는 방법입니다. 예를 들어:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 스레드가 실행할 코드</span>
    }
}
</code></pre><p>그런 다음 Thread 객체를 생성하고 Runnable 객체를 전달하여 스레드를 실행합니다:</p>
<pre><code>MyRunnable r = <span class="hljs-keyword">new</span> <span class="hljs-type">MyRunnable</span>();
Thread t = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(r);
t.start();
</code></pre><p>이 두 방법 모두 자바 프로그램에서 멀티스레딩을 구현할 때 사용됩니다. 선택은 클래스의 다른 상속 요구 사항이나 설계에 따라 달라질 수 있습니다.</p>
<h4 id="-">스레드의 상태</h4>
<p>자바에서 스레드의 상태를 확인하는 예시는 다음과 같습니다:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex10</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        <span class="hljs-comment">// 스레드 생성</span>
        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 스레드를 1초간 대기</span>
                Thread.sleep(<span class="hljs-number">1000</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        <span class="hljs-comment">// 스레드 상태 출력</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Before start: "</span> + thread.getState());

        <span class="hljs-comment">// 스레드 시작</span>
        thread.start();

        <span class="hljs-comment">// 스레드 상태 출력</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After start: "</span> + thread.getState());

        <span class="hljs-comment">// 스레드가 종료될 때까지 대기</span>
        <span class="hljs-keyword">try</span> {
            thread.<span class="hljs-keyword">join</span>();
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        <span class="hljs-comment">// 스레드 상태 출력</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After join: "</span> + thread.getState());
    }
}
</code></pre><p>이 코드는 스레드를 생성하고, getState() 메소드를 사용하여 스레드의 상태를 확인하는 과정을 보여줍니다. 스레드가 시작되기 전(Before start), 시작된 후(After start), 그리고 종료된 후(After join)의 상태를 출력합니다. 이러한 방법으로 스레드의 생명 주기 동안 각 단계에서 스레드의 상태를 확인할 수 있습니다</p>
<h4 id="-">동기화</h4>
<p>스레드 간의 경쟁 상태(Race Condition)는 여러 스레드가 동시에 공유 자원에 접근하려고 할 때 발생합니다. 특히, 한 스레드가 데이터를 읽거나 쓰는 동안 다른 스레드가 동일한 데이터에 접근하여 변경을 시도할 때 이러한 상태가 발생할 수 있습니다. 이로 인해 데이터의 불일치 문제가 발생하며, 예상치 못한 결과를 초래할 수 있습니다.</p>
<p>예를 들어, 두 스레드가 동시에 같은 변수를 증가시키려고 할 때, 한 스레드가 변수의 값을 읽고, 그 값에 1을 더한 다음, 결과를 저장하기 전에 다른 스레드가 동일한 값을 읽어서 1을 더하고 저장한다면, 두 스레드 모두가 동일한 초기 값을 기반으로 연산을 수행하기 때문에, 실제로는 변수가 두 번 증가해야 하지만 실제로는 한 번만 증가하는 문제가 발생합니다.</p>
<p>따라서 멀티스레드 프로그래밍에서는 동기화 메커니즘을 사용하여 이러한 경쟁 상태를 방지하고, 공유 자원에 대한 안전한 접근을 보장해야 합니다. 이에대한 해결책으로</p>
<ul>
<li>배타적 실행: 한 스레드가 공유 데이터를 변경하는 동안 다른 스레드의 접근을 막아 일관되지 않은 상태를 방지합니다.</li>
<li>가시성: 한 스레드에서 이루어진 변경 사항을 다른 스레드에서 볼 수 있도록 합니다.</li>
<li>순서화: 코드 실행 순서가 바뀌는 것을 방지하여, 스레드 간의 예측 가능한 실행 순서를 보장합니다.
<br>동기화를 통해 스레드들이 공유 자원에 대한 접근을 순차적으로 할 수 있게 하여, 데이터의 안정성을 확보하고 예상치 못한 결과를 방지할 수 있습니다</li>
</ul>
<p>자바에서 스레드 간의 동기화는 주로 synchronized 키워드를 사용하여 이루어집니다. 이 키워드는 메소드 전체나 특정 코드 블록에 대해 동기화를 적용할 수 있으며, 공유 자원에 대한 동시 접근을 제어하여 데이터의 일관성과 무결성을 유지하는 데 목적이 있습니다. synchronized로 지정된 영역은 한 번에 하나의 스레드만이 접근할 수 있으며, 다른 스레드는 해당 영역이 사용 가능해질 때까지 대기해야 합니다.</p>
<p>예를 들어, 다음과 같이 메소드 전체를 동기화할 수 있습니다:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">synchronizedMethod</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 공유 자원을 사용하는 코드</span>
}
</code></pre><p>또는 특정 코드 블록만 동기화할 수도 있습니다:</p>
<pre><code><span class="hljs-keyword">public</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-comment">{
    synchronized(this) {
        // 공유 자원을 사용하는 코드
    }</span>
}</span>
</code></pre><p>wait(), notify(), notifyAll() 메소드를 사용하여 스레드 간의 통신을 조정할 필요가 있습니다. 이 메소드들은 스레드가 객체의 잠금을 해제하고 대기하거나, 대기 중인 스레드를 깨우는 데 사용됩니다.</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title">SharedArea</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> boolean available = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">int</span> <span class="hljs-title">getCounter</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// 스레드가 counter 값을 요청할 때, 값이 설정되지 않았다면 대기</span>
        <span class="hljs-keyword">while</span> (!available) {
            <span class="hljs-keyword">try</span> {
                wait();
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        available = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 값을 가져갔으니 다시 false로 설정</span>
        notifyAll(); <span class="hljs-comment">// 다른 스레드에게 counter 사용 가능함을 알림</span>
        <span class="hljs-keyword">return</span> counter;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">setCounter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>) </span>{
        <span class="hljs-comment">// 스레드가 counter 값을 설정할 때, 이전 값이 아직 사용 중이라면 대기</span>
        <span class="hljs-keyword">while</span> (available) {
            <span class="hljs-keyword">try</span> {
                wait();
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        counter = <span class="hljs-keyword">value</span>;
        available = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 새 값이 설정되었으니 true로 설정</span>
        notifyAll(); <span class="hljs-comment">// 다른 스레드에게 새 값이 설정됨을 알림</span>
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">ProducerThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> {
    <span class="hljs-keyword">private</span> SharedArea sharedArea;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProducerThread</span>(<span class="hljs-params">SharedArea sharedArea</span>) </span>{
        <span class="hljs-keyword">this</span>.sharedArea = sharedArea;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            sharedArea.setCounter(i);
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"생산자: "</span> + i + <span class="hljs-string">" 설정"</span>);
        }
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> {
    <span class="hljs-keyword">private</span> SharedArea sharedArea;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerThread</span>(<span class="hljs-params">SharedArea sharedArea</span>) </span>{
        <span class="hljs-keyword">this</span>.sharedArea = sharedArea;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">value</span> = sharedArea.getCounter();
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"소비자: "</span> + <span class="hljs-keyword">value</span> + <span class="hljs-string">" 가져옴"</span>);
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ex17</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) </span>{
        SharedArea sharedArea = <span class="hljs-keyword">new</span> SharedArea();
        Thread producer = <span class="hljs-keyword">new</span> ProducerThread(sharedArea);
        Thread consumer = <span class="hljs-keyword">new</span> ConsumerThread(sharedArea);

        producer.start();
        consumer.start();
    }
}
</code></pre><h4 id="-">스레드 풀</h4>
<p>스레드 풀을 사용하는 방법은 ExecutorService 인터페이스와 Executors 클래스를 활용하는 것입니다. 스레드 풀은 미리 생성된 스레드 집합을 관리하여, 작업을 효율적으로 처리할 수 있게 해줍니다. 다음은 스레드 풀을 사용하는 기본적인 단계입니다:</p>
<p>스레드 풀 생성: Executors 클래스의 정적 메소드를 사용하여 스레드 풀을 생성합니다. 예를 들어, 고정된 수의 스레드를 가진 풀을 만들고 싶다면 newFixedThreadPool 메소드를 사용할 수 있습니다.</p>
<pre><code>ExecutorService executorService = Executors.<span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(<span class="hljs-number">10</span>);
 <span class="hljs-comment">// 10개의 스레드를 가진 풀 생성</span>
</code></pre><p>작업 제출: execute 또는 submit 메소드를 사용하여 스레드 풀에 작업을 제출합니다. execute는 반환 값이 없는 작업에 사용되며, submit은 Future 객체를 통해 결과를 반환할 수 있는 작업에 사용됩니다.</p>
<pre><code>executorService.submit(<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> {
    <span class="hljs-regexp">//</span> 여기에 작업 코드를 작성
});
</code></pre><p>스레드 풀 종료: 작업이 모두 완료되면 shutdown 메소드를 호출하여 스레드 풀을 종료합니다. 이는 스레드 풀이 더 이상 새로운 작업을 받지 않도록 하며, 현재 진행 중인 작업들은 완료됩니다.</p>
<pre><code>executorService.shutdown()<span class="hljs-comment">;</span>
</code></pre><p>스레드 풀을 사용하면 스레드 생성과 소멸에 따른 오버헤드를 줄이고, 시스템 자원을 효율적으로 사용할 수 있습니다</p>
<p>주요 스레드풀의 종류는 다음과 같습니다:</p>
<ul>
<li>newFixedThreadPool: 고정된 수의 스레드를 생성하고, 스레드가 종료되면 새로운 스레드를 생성하여 수를 유지합니다.</li>
<li>newCachedThreadPool: 필요에 따라 스레드 수를 증가시키며, 사용하지 않는 스레드는 일정 시간 후에 제거합니다. 최대 스레드 수는 Integer.MAX_VALUE입니다.</li>
<li>newSingleThreadExecutor: 단일 스레드를 사용하여 작업을 순차적으로 실행합니다.</li>
<li>newScheduledThreadPool: 예약된 작업이나 반복 작업을 위한 스레드풀로, 특정 시간 이후 또는 주기적으로 작업을 실행할 때 사용됩니다.</li>
</ul>
<p>이러한 스레드풀은 자바의 java.util.concurrent.Executors 클래스를 통해 제공되며, 각각의 사용 사례에 따라 적절한 스레드풀을 선택하여 사용할 수 있습니다.</p>
<pre><code><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// 스레드풀 생성: 10개의 스레드를 유지하는 고정된 스레드풀</span>
        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);

        <span class="hljs-comment">// 100개의 작업을 스레드풀에 제출</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
            executor.submit(<span class="hljs-keyword">new</span> Task(i));
        }

        <span class="hljs-comment">// 스레드풀 종료 요청</span>
        executor.shutdown();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 모든 작업이 완료될 때까지 대기</span>
            executor.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> taskId;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>{
        <span class="hljs-keyword">this</span>.taskId = id;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 작업 내용</span>
        System.out.println(<span class="hljs-string">"Task ID : "</span> + <span class="hljs-keyword">this</span>.taskId + <span class="hljs-string">" performed by "</span> 
                           + Thread.currentThread().getName());
    }
}
</code></pre><p>이 코드는 newFixedThreadPool 메소드를 사용하여 고정된 수(10개)의 스레드를 가진 스레드풀을 생성합니다. 그런 다음 for 루프를 사용하여 100개의 작업을 스레드풀에 제출합니다. 각 작업은 Task 클래스의 인스턴스로, Runnable 인터페이스를 구현합니다. 마지막으로 shutdown 메소드를 호출하여 스레드풀의 종료를 요청하고, awaitTermination 메소드로 모든 작업이 완료될 때까지 대기합니다.</p>
<p>Callable 인터페이스를 사용하여 스레드 풀에서 작업을 수행하고 결과를 반환받을 수도 있습니다.</p>
<ol>
<li>Callable 인터페이스 구현: Callable 인터페이스를 구현하는 클래스를 생성하고, call() 메소드를 오버라이드하여 작업 내용을 정의합니다. call() 메소드는 작업의 결과를 반환합니다.</li>
</ol>
<pre><code><span class="hljs-keyword">import</span> java.util.concurrent.Callable;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> WordLengthCallable implements Callable&lt;Integer&gt; {
    <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>;

    <span class="hljs-keyword">public</span> WordLengthCallable(<span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>) {
        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">word</span> = <span class="hljs-keyword">word</span>;
    }

    @Override
    <span class="hljs-keyword">public</span> Integer call() {
        <span class="hljs-built_in">return</span> <span class="hljs-keyword">word</span>.length(); <span class="hljs-comment">// 단어의 길이를 반환</span>
    }
}
</code></pre><ol>
<li>스레드 풀 생성: Executors 클래스의 정적 메소드를 사용하여 스레드 풀을 생성합니다.</li>
</ol>
<pre><code><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.concurrent.ExecutorService;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.concurrent.Executors;</span>

ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>); 
<span class="hljs-comment">// 3개의 스레드를 가진 풀 생성</span>
</code></pre><ol>
<li>작업 제출 및 결과 처리: submit() 메소드를 사용하여 Callable 객체를 스레드 풀에 제출하고, Future 객체를 통해 결과를 처리합니다.</li>
</ol>
<pre><code><span class="hljs-keyword">import</span> java.util.concurrent.Future;

Callable&lt;<span class="hljs-built_in">Integer</span>&gt; callable = <span class="hljs-literal">new</span> WordLengthCallable(<span class="hljs-string">"Hello"</span>);
Future&lt;<span class="hljs-built_in">Integer</span>&gt; future = pool.submit(callable);

<span class="hljs-comment">// 나중에 결과를 가져옵니다. 필요하다면 이 부분에서 블로킹될 수 있습니다.</span>

<span class="hljs-built_in">Integer</span> result = future.get();
</code></pre><ol>
<li>스레드 풀 종료: 모든 작업이 완료된 후에는 스레드 풀을 종료합니다.</li>
</ol>
<pre><code>pool.shutdown()<span class="hljs-comment">;</span>
</code></pre><p>Callable을 사용하면 작업의 결과를 Future 객체를 통해 비동기적으로 받을 수 있으며, 예외 처리도 보다 용이합니다</p>

    </body>
</html>